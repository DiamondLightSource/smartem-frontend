/**
 * Generated by orval v7.13.0 üç∫
 * Do not edit manually.
 * SmartEM Decisions Backend API
 * API for accessing and managing electron microscopy data
 * OpenAPI spec version: 0.1.dev372+g0f036fa24
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import { customInstance } from '../../mutator'
import type {
  AcquisitionCreateRequest,
  AcquisitionResponse,
  AcquisitionUpdateRequest,
  AgentInstructionAcknowledgement,
  AgentInstructionAcknowledgementResponse,
  AtlasCreateRequest,
  AtlasResponse,
  AtlasTileCreateRequest,
  AtlasTileGridSquarePositionResponse,
  AtlasTileResponse,
  AtlasTileUpdateRequest,
  AtlasUpdateRequest,
  CreateManagedSessionDebugSessionsCreateManagedPostBody,
  CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody,
  CreateTestSessionDebugSessionsCreatePostBody,
  FoilHoleCreateRequest,
  FoilHoleResponse,
  FoilHoleUpdateRequest,
  GetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet200,
  GetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet200,
  GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  GetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet200,
  GetModelWeightsForGridGridGridUuidModelWeightsGet200,
  GridCreateRequest,
  GridResponse,
  GridSquare,
  GridSquareCreateRequest,
  GridSquarePositionRequest,
  GridSquareResponse,
  GridSquareUpdateRequest,
  GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams,
  GridUpdateRequest,
  HTTPValidationError,
  LatentRepresentationResponse,
  MicrographCreateRequest,
  MicrographResponse,
  MicrographUpdateRequest,
  OverallQualityPrediction,
  QualityMetricsResponse,
  QualityPredictionCreateRequest,
  QualityPredictionModelCreateRequest,
  QualityPredictionModelResponse,
  QualityPredictionModelUpdateRequest,
  QualityPredictionResponse,
} from '.././models'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Get API status and configuration information
 * @summary Get Status
 */
export const getStatusStatusGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/status`, method: 'GET', signal }, options)
}

export const getGetStatusStatusGetQueryKey = () => {
  return [`/status`] as const
}

export const getGetStatusStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getStatusStatusGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusGet>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetStatusStatusGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatusStatusGet>>> = ({ signal }) =>
    getStatusStatusGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStatusStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStatusStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStatusStatusGet>>
>
export type GetStatusStatusGetQueryError = unknown

export function useGetStatusStatusGet<
  TData = Awaited<ReturnType<typeof getStatusStatusGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusGet>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatusStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getStatusStatusGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatusStatusGet<
  TData = Awaited<ReturnType<typeof getStatusStatusGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatusStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getStatusStatusGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatusStatusGet<
  TData = Awaited<ReturnType<typeof getStatusStatusGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Status
 */

export function useGetStatusStatusGet<
  TData = Awaited<ReturnType<typeof getStatusStatusGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStatusStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Health check endpoint with actual connectivity checks
 * @summary Get Health
 */
export const getHealthHealthGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/health`, method: 'GET', signal }, options)
}

export const getGetHealthHealthGetQueryKey = () => {
  return [`/health`] as const
}

export const getGetHealthHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getHealthHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthHealthGet>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetHealthHealthGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealthHealthGet>>> = ({ signal }) =>
    getHealthHealthGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHealthHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHealthHealthGet>>
>
export type GetHealthHealthGetQueryError = unknown

export function useGetHealthHealthGet<
  TData = Awaited<ReturnType<typeof getHealthHealthGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthHealthGet>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof getHealthHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthHealthGet<
  TData = Awaited<ReturnType<typeof getHealthHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHealthHealthGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof getHealthHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthHealthGet<
  TData = Awaited<ReturnType<typeof getHealthHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthHealthGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Health
 */

export function useGetHealthHealthGet<
  TData = Awaited<ReturnType<typeof getHealthHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthHealthGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHealthHealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all acquisitions
 * @summary Get Acquisitions
 */
export const getAcquisitionsAcquisitionsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AcquisitionResponse[]>(
    { url: `/acquisitions`, method: 'GET', signal },
    options
  )
}

export const getGetAcquisitionsAcquisitionsGetQueryKey = () => {
  return [`/acquisitions`] as const
}

export const getGetAcquisitionsAcquisitionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAcquisitionsAcquisitionsGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>> = ({
    signal,
  }) => getAcquisitionsAcquisitionsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcquisitionsAcquisitionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>
>
export type GetAcquisitionsAcquisitionsGetQueryError = unknown

export function useGetAcquisitionsAcquisitionsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
          TError,
          Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcquisitionsAcquisitionsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
          TError,
          Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcquisitionsAcquisitionsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Acquisitions
 */

export function useGetAcquisitionsAcquisitionsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAcquisitionsAcquisitionsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcquisitionsAcquisitionsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new acquisition
 * @summary Create Acquisition
 */
export const createAcquisitionAcquisitionsPost = (
  acquisitionCreateRequest: AcquisitionCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AcquisitionResponse>(
    {
      url: `/acquisitions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: acquisitionCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateAcquisitionAcquisitionsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAcquisitionAcquisitionsPost>>,
    TError,
    { data: AcquisitionCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAcquisitionAcquisitionsPost>>,
  TError,
  { data: AcquisitionCreateRequest },
  TContext
> => {
  const mutationKey = ['createAcquisitionAcquisitionsPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAcquisitionAcquisitionsPost>>,
    { data: AcquisitionCreateRequest }
  > = (props) => {
    const { data } = props ?? {}

    return createAcquisitionAcquisitionsPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateAcquisitionAcquisitionsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAcquisitionAcquisitionsPost>>
>
export type CreateAcquisitionAcquisitionsPostMutationBody = AcquisitionCreateRequest
export type CreateAcquisitionAcquisitionsPostMutationError = HTTPValidationError

/**
 * @summary Create Acquisition
 */
export const useCreateAcquisitionAcquisitionsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAcquisitionAcquisitionsPost>>,
      TError,
      { data: AcquisitionCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createAcquisitionAcquisitionsPost>>,
  TError,
  { data: AcquisitionCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateAcquisitionAcquisitionsPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get a single acquisition by ID
 * @summary Get Acquisition
 */
export const getAcquisitionAcquisitionsAcquisitionUuidGet = (
  acquisitionUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AcquisitionResponse>(
    { url: `/acquisitions/${acquisitionUuid}`, method: 'GET', signal },
    options
  )
}

export const getGetAcquisitionAcquisitionsAcquisitionUuidGetQueryKey = (
  acquisitionUuid?: string
) => {
  return [`/acquisitions/${acquisitionUuid}`] as const
}

export const getGetAcquisitionAcquisitionsAcquisitionUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetAcquisitionAcquisitionsAcquisitionUuidGetQueryKey(acquisitionUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>
  > = ({ signal }) =>
    getAcquisitionAcquisitionsAcquisitionUuidGet(acquisitionUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!acquisitionUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcquisitionAcquisitionsAcquisitionUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>
>
export type GetAcquisitionAcquisitionsAcquisitionUuidGetQueryError = HTTPValidationError

export function useGetAcquisitionAcquisitionsAcquisitionUuidGet<
  TData = Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcquisitionAcquisitionsAcquisitionUuidGet<
  TData = Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcquisitionAcquisitionsAcquisitionUuidGet<
  TData = Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Acquisition
 */

export function useGetAcquisitionAcquisitionsAcquisitionUuidGet<
  TData = Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionAcquisitionsAcquisitionUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcquisitionAcquisitionsAcquisitionUuidGetQueryOptions(
    acquisitionUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an acquisition
 * @summary Update Acquisition
 */
export const updateAcquisitionAcquisitionsAcquisitionUuidPut = (
  acquisitionUuid: string,
  acquisitionUpdateRequest: AcquisitionUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AcquisitionResponse>(
    {
      url: `/acquisitions/${acquisitionUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: acquisitionUpdateRequest,
    },
    options
  )
}

export const getUpdateAcquisitionAcquisitionsAcquisitionUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAcquisitionAcquisitionsAcquisitionUuidPut>>,
    TError,
    { acquisitionUuid: string; data: AcquisitionUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAcquisitionAcquisitionsAcquisitionUuidPut>>,
  TError,
  { acquisitionUuid: string; data: AcquisitionUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAcquisitionAcquisitionsAcquisitionUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAcquisitionAcquisitionsAcquisitionUuidPut>>,
    { acquisitionUuid: string; data: AcquisitionUpdateRequest }
  > = (props) => {
    const { acquisitionUuid, data } = props ?? {}

    return updateAcquisitionAcquisitionsAcquisitionUuidPut(acquisitionUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateAcquisitionAcquisitionsAcquisitionUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAcquisitionAcquisitionsAcquisitionUuidPut>>
>
export type UpdateAcquisitionAcquisitionsAcquisitionUuidPutMutationBody = AcquisitionUpdateRequest
export type UpdateAcquisitionAcquisitionsAcquisitionUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Acquisition
 */
export const useUpdateAcquisitionAcquisitionsAcquisitionUuidPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAcquisitionAcquisitionsAcquisitionUuidPut>>,
      TError,
      { acquisitionUuid: string; data: AcquisitionUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAcquisitionAcquisitionsAcquisitionUuidPut>>,
  TError,
  { acquisitionUuid: string; data: AcquisitionUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAcquisitionAcquisitionsAcquisitionUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete an acquisition
 * @summary Delete Acquisition
 */
export const deleteAcquisitionAcquisitionsAcquisitionUuidDelete = (
  acquisitionUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>(
    { url: `/acquisitions/${acquisitionUuid}`, method: 'DELETE' },
    options
  )
}

export const getDeleteAcquisitionAcquisitionsAcquisitionUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAcquisitionAcquisitionsAcquisitionUuidDelete>>,
    TError,
    { acquisitionUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAcquisitionAcquisitionsAcquisitionUuidDelete>>,
  TError,
  { acquisitionUuid: string },
  TContext
> => {
  const mutationKey = ['deleteAcquisitionAcquisitionsAcquisitionUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAcquisitionAcquisitionsAcquisitionUuidDelete>>,
    { acquisitionUuid: string }
  > = (props) => {
    const { acquisitionUuid } = props ?? {}

    return deleteAcquisitionAcquisitionsAcquisitionUuidDelete(acquisitionUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteAcquisitionAcquisitionsAcquisitionUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAcquisitionAcquisitionsAcquisitionUuidDelete>>
>

export type DeleteAcquisitionAcquisitionsAcquisitionUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Acquisition
 */
export const useDeleteAcquisitionAcquisitionsAcquisitionUuidDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAcquisitionAcquisitionsAcquisitionUuidDelete>>,
      TError,
      { acquisitionUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAcquisitionAcquisitionsAcquisitionUuidDelete>>,
  TError,
  { acquisitionUuid: string },
  TContext
> => {
  const mutationOptions =
    getDeleteAcquisitionAcquisitionsAcquisitionUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all grids
 * @summary Get Grids
 */
export const getGridsGridsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridResponse[]>({ url: `/grids`, method: 'GET', signal }, options)
}

export const getGetGridsGridsGetQueryKey = () => {
  return [`/grids`] as const
}

export const getGetGridsGridsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridsGridsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGridsGridsGet>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGridsGridsGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGridsGridsGet>>> = ({ signal }) =>
    getGridsGridsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridsGridsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridsGridsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getGridsGridsGet>>>
export type GetGridsGridsGetQueryError = unknown

export function useGetGridsGridsGet<
  TData = Awaited<ReturnType<typeof getGridsGridsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGridsGridsGet>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsGridsGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsGridsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsGridsGet<
  TData = Awaited<ReturnType<typeof getGridsGridsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGridsGridsGet>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsGridsGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsGridsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsGridsGet<
  TData = Awaited<ReturnType<typeof getGridsGridsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGridsGridsGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Grids
 */

export function useGetGridsGridsGet<
  TData = Awaited<ReturnType<typeof getGridsGridsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGridsGridsGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridsGridsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single grid by ID
 * @summary Get Grid
 */
export const getGridGridsGridUuidGet = (
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridResponse>({ url: `/grids/${gridUuid}`, method: 'GET', signal }, options)
}

export const getGetGridGridsGridUuidGetQueryKey = (gridUuid?: string) => {
  return [`/grids/${gridUuid}`] as const
}

export const getGetGridGridsGridUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGridGridsGridUuidGetQueryKey(gridUuid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>> = ({
    signal,
  }) => getGridGridsGridUuidGet(gridUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!gridUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type GetGridGridsGridUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridGridsGridUuidGet>>
>
export type GetGridGridsGridUuidGetQueryError = HTTPValidationError

export function useGetGridGridsGridUuidGet<
  TData = Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getGridGridsGridUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridGridsGridUuidGet<
  TData = Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getGridGridsGridUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridGridsGridUuidGet<
  TData = Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Grid
 */

export function useGetGridGridsGridUuidGet<
  TData = Awaited<ReturnType<typeof getGridGridsGridUuidGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridGridsGridUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridGridsGridUuidGetQueryOptions(gridUuid, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a grid
 * @summary Update Grid
 */
export const updateGridGridsGridUuidPut = (
  gridUuid: string,
  gridUpdateRequest: GridUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<GridResponse>(
    {
      url: `/grids/${gridUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: gridUpdateRequest,
    },
    options
  )
}

export const getUpdateGridGridsGridUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGridGridsGridUuidPut>>,
    TError,
    { gridUuid: string; data: GridUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGridGridsGridUuidPut>>,
  TError,
  { gridUuid: string; data: GridUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateGridGridsGridUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGridGridsGridUuidPut>>,
    { gridUuid: string; data: GridUpdateRequest }
  > = (props) => {
    const { gridUuid, data } = props ?? {}

    return updateGridGridsGridUuidPut(gridUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateGridGridsGridUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGridGridsGridUuidPut>>
>
export type UpdateGridGridsGridUuidPutMutationBody = GridUpdateRequest
export type UpdateGridGridsGridUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Grid
 */
export const useUpdateGridGridsGridUuidPut = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateGridGridsGridUuidPut>>,
      TError,
      { gridUuid: string; data: GridUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateGridGridsGridUuidPut>>,
  TError,
  { gridUuid: string; data: GridUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateGridGridsGridUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a grid by publishing to RabbitMQ
 * @summary Delete Grid
 */
export const deleteGridGridsGridUuidDelete = (
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/grids/${gridUuid}`, method: 'DELETE' }, options)
}

export const getDeleteGridGridsGridUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGridGridsGridUuidDelete>>,
    TError,
    { gridUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGridGridsGridUuidDelete>>,
  TError,
  { gridUuid: string },
  TContext
> => {
  const mutationKey = ['deleteGridGridsGridUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGridGridsGridUuidDelete>>,
    { gridUuid: string }
  > = (props) => {
    const { gridUuid } = props ?? {}

    return deleteGridGridsGridUuidDelete(gridUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteGridGridsGridUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteGridGridsGridUuidDelete>>
>

export type DeleteGridGridsGridUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Grid
 */
export const useDeleteGridGridsGridUuidDelete = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteGridGridsGridUuidDelete>>,
      TError,
      { gridUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteGridGridsGridUuidDelete>>,
  TError,
  { gridUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteGridGridsGridUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all grids for a specific acquisition
 * @summary Get Acquisition Grids
 */
export const getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet = (
  acquisitionUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridResponse[]>(
    { url: `/acquisitions/${acquisitionUuid}/grids`, method: 'GET', signal },
    options
  )
}

export const getGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGetQueryKey = (
  acquisitionUuid?: string
) => {
  return [`/acquisitions/${acquisitionUuid}/grids`] as const
}

export const getGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGetQueryKey(acquisitionUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>
  > = ({ signal }) =>
    getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet(acquisitionUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!acquisitionUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>
>
export type GetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGetQueryError = HTTPValidationError

export function useGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
          TError,
          Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
          TError,
          Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Acquisition Grids
 */

export function useGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet<
  TData = Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
  TError = HTTPValidationError,
>(
  acquisitionUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAcquisitionGridsAcquisitionsAcquisitionUuidGridsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcquisitionGridsAcquisitionsAcquisitionUuidGridsGetQueryOptions(
    acquisitionUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new grid for a specific acquisition
 * @summary Create Acquisition Grid
 */
export const createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost = (
  acquisitionUuid: string,
  gridCreateRequest: GridCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridResponse>(
    {
      url: `/acquisitions/${acquisitionUuid}/grids`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: gridCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateAcquisitionGridAcquisitionsAcquisitionUuidGridsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost>>,
    TError,
    { acquisitionUuid: string; data: GridCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost>>,
  TError,
  { acquisitionUuid: string; data: GridCreateRequest },
  TContext
> => {
  const mutationKey = ['createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost>>,
    { acquisitionUuid: string; data: GridCreateRequest }
  > = (props) => {
    const { acquisitionUuid, data } = props ?? {}

    return createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost(
      acquisitionUuid,
      data,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateAcquisitionGridAcquisitionsAcquisitionUuidGridsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost>>
>
export type CreateAcquisitionGridAcquisitionsAcquisitionUuidGridsPostMutationBody =
  GridCreateRequest
export type CreateAcquisitionGridAcquisitionsAcquisitionUuidGridsPostMutationError =
  HTTPValidationError

/**
 * @summary Create Acquisition Grid
 */
export const useCreateAcquisitionGridAcquisitionsAcquisitionUuidGridsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost>>,
      TError,
      { acquisitionUuid: string; data: GridCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createAcquisitionGridAcquisitionsAcquisitionUuidGridsPost>>,
  TError,
  { acquisitionUuid: string; data: GridCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateAcquisitionGridAcquisitionsAcquisitionUuidGridsPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * All squares on a grid have been registered at low mag
 * @summary Grid Registered
 */
export const gridRegisteredGridsGridUuidRegisteredPost = (
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<boolean>(
    { url: `/grids/${gridUuid}/registered`, method: 'POST', signal },
    options
  )
}

export const getGridRegisteredGridsGridUuidRegisteredPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gridRegisteredGridsGridUuidRegisteredPost>>,
    TError,
    { gridUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof gridRegisteredGridsGridUuidRegisteredPost>>,
  TError,
  { gridUuid: string },
  TContext
> => {
  const mutationKey = ['gridRegisteredGridsGridUuidRegisteredPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gridRegisteredGridsGridUuidRegisteredPost>>,
    { gridUuid: string }
  > = (props) => {
    const { gridUuid } = props ?? {}

    return gridRegisteredGridsGridUuidRegisteredPost(gridUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GridRegisteredGridsGridUuidRegisteredPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof gridRegisteredGridsGridUuidRegisteredPost>>
>

export type GridRegisteredGridsGridUuidRegisteredPostMutationError = HTTPValidationError

/**
 * @summary Grid Registered
 */
export const useGridRegisteredGridsGridUuidRegisteredPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gridRegisteredGridsGridUuidRegisteredPost>>,
      TError,
      { gridUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gridRegisteredGridsGridUuidRegisteredPost>>,
  TError,
  { gridUuid: string },
  TContext
> => {
  const mutationOptions = getGridRegisteredGridsGridUuidRegisteredPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all atlases
 * @summary Get Atlases
 */
export const getAtlasesAtlasesGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasResponse[]>({ url: `/atlases`, method: 'GET', signal }, options)
}

export const getGetAtlasesAtlasesGetQueryKey = () => {
  return [`/atlases`] as const
}

export const getGetAtlasesAtlasesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAtlasesAtlasesGet>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAtlasesAtlasesGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAtlasesAtlasesGet>>> = ({ signal }) =>
    getAtlasesAtlasesGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAtlasesAtlasesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAtlasesAtlasesGet>>
>
export type GetAtlasesAtlasesGetQueryError = unknown

export function useGetAtlasesAtlasesGet<
  TData = Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasesAtlasesGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasesAtlasesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasesAtlasesGet<
  TData = Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasesAtlasesGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasesAtlasesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasesAtlasesGet<
  TData = Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasesAtlasesGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Atlases
 */

export function useGetAtlasesAtlasesGet<
  TData = Awaited<ReturnType<typeof getAtlasesAtlasesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasesAtlasesGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAtlasesAtlasesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single atlas by ID
 * @summary Get Atlas
 */
export const getAtlasAtlasesAtlasUuidGet = (
  atlasUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasResponse>(
    { url: `/atlases/${atlasUuid}`, method: 'GET', signal },
    options
  )
}

export const getGetAtlasAtlasesAtlasUuidGetQueryKey = (atlasUuid?: string) => {
  return [`/atlases/${atlasUuid}`] as const
}

export const getGetAtlasAtlasesAtlasUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAtlasAtlasesAtlasUuidGetQueryKey(atlasUuid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>> = ({
    signal,
  }) => getAtlasAtlasesAtlasUuidGet(atlasUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!atlasUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type GetAtlasAtlasesAtlasUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>
>
export type GetAtlasAtlasesAtlasUuidGetQueryError = HTTPValidationError

export function useGetAtlasAtlasesAtlasUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasAtlasesAtlasUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasAtlasesAtlasUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Atlas
 */

export function useGetAtlasAtlasesAtlasUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasAtlasesAtlasUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAtlasAtlasesAtlasUuidGetQueryOptions(atlasUuid, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an atlas
 * @summary Update Atlas
 */
export const updateAtlasAtlasesAtlasUuidPut = (
  atlasUuid: string,
  atlasUpdateRequest: AtlasUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AtlasResponse>(
    {
      url: `/atlases/${atlasUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: atlasUpdateRequest,
    },
    options
  )
}

export const getUpdateAtlasAtlasesAtlasUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAtlasAtlasesAtlasUuidPut>>,
    TError,
    { atlasUuid: string; data: AtlasUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAtlasAtlasesAtlasUuidPut>>,
  TError,
  { atlasUuid: string; data: AtlasUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAtlasAtlasesAtlasUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAtlasAtlasesAtlasUuidPut>>,
    { atlasUuid: string; data: AtlasUpdateRequest }
  > = (props) => {
    const { atlasUuid, data } = props ?? {}

    return updateAtlasAtlasesAtlasUuidPut(atlasUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateAtlasAtlasesAtlasUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAtlasAtlasesAtlasUuidPut>>
>
export type UpdateAtlasAtlasesAtlasUuidPutMutationBody = AtlasUpdateRequest
export type UpdateAtlasAtlasesAtlasUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Atlas
 */
export const useUpdateAtlasAtlasesAtlasUuidPut = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAtlasAtlasesAtlasUuidPut>>,
      TError,
      { atlasUuid: string; data: AtlasUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAtlasAtlasesAtlasUuidPut>>,
  TError,
  { atlasUuid: string; data: AtlasUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAtlasAtlasesAtlasUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete an atlas by publishing to RabbitMQ
 * @summary Delete Atlas
 */
export const deleteAtlasAtlasesAtlasUuidDelete = (
  atlasUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/atlases/${atlasUuid}`, method: 'DELETE' }, options)
}

export const getDeleteAtlasAtlasesAtlasUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAtlasAtlasesAtlasUuidDelete>>,
    TError,
    { atlasUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAtlasAtlasesAtlasUuidDelete>>,
  TError,
  { atlasUuid: string },
  TContext
> => {
  const mutationKey = ['deleteAtlasAtlasesAtlasUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAtlasAtlasesAtlasUuidDelete>>,
    { atlasUuid: string }
  > = (props) => {
    const { atlasUuid } = props ?? {}

    return deleteAtlasAtlasesAtlasUuidDelete(atlasUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteAtlasAtlasesAtlasUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAtlasAtlasesAtlasUuidDelete>>
>

export type DeleteAtlasAtlasesAtlasUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Atlas
 */
export const useDeleteAtlasAtlasesAtlasUuidDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAtlasAtlasesAtlasUuidDelete>>,
      TError,
      { atlasUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAtlasAtlasesAtlasUuidDelete>>,
  TError,
  { atlasUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteAtlasAtlasesAtlasUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get the atlas for a specific grid
 * @summary Get Grid Atlas
 */
export const getGridAtlasGridsGridUuidAtlasGet = (
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasResponse>(
    { url: `/grids/${gridUuid}/atlas`, method: 'GET', signal },
    options
  )
}

export const getGetGridAtlasGridsGridUuidAtlasGetQueryKey = (gridUuid?: string) => {
  return [`/grids/${gridUuid}/atlas`] as const
}

export const getGetGridAtlasGridsGridUuidAtlasGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGridAtlasGridsGridUuidAtlasGetQueryKey(gridUuid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>> = ({
    signal,
  }) => getGridAtlasGridsGridUuidAtlasGet(gridUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!gridUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridAtlasGridsGridUuidAtlasGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>
>
export type GetGridAtlasGridsGridUuidAtlasGetQueryError = HTTPValidationError

export function useGetGridAtlasGridsGridUuidAtlasGet<
  TData = Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
          TError,
          Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridAtlasGridsGridUuidAtlasGet<
  TData = Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
          TError,
          Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridAtlasGridsGridUuidAtlasGet<
  TData = Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Grid Atlas
 */

export function useGetGridAtlasGridsGridUuidAtlasGet<
  TData = Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridAtlasGridsGridUuidAtlasGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridAtlasGridsGridUuidAtlasGetQueryOptions(gridUuid, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new atlas for a grid
 * @summary Create Grid Atlas
 */
export const createGridAtlasGridsGridUuidAtlasPost = (
  gridUuid: string,
  atlasCreateRequest: AtlasCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasResponse>(
    {
      url: `/grids/${gridUuid}/atlas`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: atlasCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateGridAtlasGridsGridUuidAtlasPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGridAtlasGridsGridUuidAtlasPost>>,
    TError,
    { gridUuid: string; data: AtlasCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGridAtlasGridsGridUuidAtlasPost>>,
  TError,
  { gridUuid: string; data: AtlasCreateRequest },
  TContext
> => {
  const mutationKey = ['createGridAtlasGridsGridUuidAtlasPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGridAtlasGridsGridUuidAtlasPost>>,
    { gridUuid: string; data: AtlasCreateRequest }
  > = (props) => {
    const { gridUuid, data } = props ?? {}

    return createGridAtlasGridsGridUuidAtlasPost(gridUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateGridAtlasGridsGridUuidAtlasPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGridAtlasGridsGridUuidAtlasPost>>
>
export type CreateGridAtlasGridsGridUuidAtlasPostMutationBody = AtlasCreateRequest
export type CreateGridAtlasGridsGridUuidAtlasPostMutationError = HTTPValidationError

/**
 * @summary Create Grid Atlas
 */
export const useCreateGridAtlasGridsGridUuidAtlasPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGridAtlasGridsGridUuidAtlasPost>>,
      TError,
      { gridUuid: string; data: AtlasCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createGridAtlasGridsGridUuidAtlasPost>>,
  TError,
  { gridUuid: string; data: AtlasCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateGridAtlasGridsGridUuidAtlasPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all atlas tiles
 * @summary Get Atlas Tiles
 */
export const getAtlasTilesAtlasTilesGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasTileResponse[]>(
    { url: `/atlas-tiles`, method: 'GET', signal },
    options
  )
}

export const getGetAtlasTilesAtlasTilesGetQueryKey = () => {
  return [`/atlas-tiles`] as const
}

export const getGetAtlasTilesAtlasTilesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAtlasTilesAtlasTilesGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>> = ({
    signal,
  }) => getAtlasTilesAtlasTilesGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAtlasTilesAtlasTilesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>
>
export type GetAtlasTilesAtlasTilesGetQueryError = unknown

export function useGetAtlasTilesAtlasTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasTilesAtlasTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasTilesAtlasTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Atlas Tiles
 */

export function useGetAtlasTilesAtlasTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTilesAtlasTilesGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAtlasTilesAtlasTilesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single atlas tile by ID
 * @summary Get Atlas Tile
 */
export const getAtlasTileAtlasTilesTileUuidGet = (
  tileUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasTileResponse>(
    { url: `/atlas-tiles/${tileUuid}`, method: 'GET', signal },
    options
  )
}

export const getGetAtlasTileAtlasTilesTileUuidGetQueryKey = (tileUuid?: string) => {
  return [`/atlas-tiles/${tileUuid}`] as const
}

export const getGetAtlasTileAtlasTilesTileUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
  TError = HTTPValidationError,
>(
  tileUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAtlasTileAtlasTilesTileUuidGetQueryKey(tileUuid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>> = ({
    signal,
  }) => getAtlasTileAtlasTilesTileUuidGet(tileUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!tileUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAtlasTileAtlasTilesTileUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>
>
export type GetAtlasTileAtlasTilesTileUuidGetQueryError = HTTPValidationError

export function useGetAtlasTileAtlasTilesTileUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
  TError = HTTPValidationError,
>(
  tileUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasTileAtlasTilesTileUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
  TError = HTTPValidationError,
>(
  tileUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasTileAtlasTilesTileUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
  TError = HTTPValidationError,
>(
  tileUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Atlas Tile
 */

export function useGetAtlasTileAtlasTilesTileUuidGet<
  TData = Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>,
  TError = HTTPValidationError,
>(
  tileUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAtlasTileAtlasTilesTileUuidGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAtlasTileAtlasTilesTileUuidGetQueryOptions(tileUuid, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an atlas tile
 * @summary Update Atlas Tile
 */
export const updateAtlasTileAtlasTilesTileUuidPut = (
  tileUuid: string,
  atlasTileUpdateRequest: AtlasTileUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AtlasTileResponse>(
    {
      url: `/atlas-tiles/${tileUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: atlasTileUpdateRequest,
    },
    options
  )
}

export const getUpdateAtlasTileAtlasTilesTileUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAtlasTileAtlasTilesTileUuidPut>>,
    TError,
    { tileUuid: string; data: AtlasTileUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAtlasTileAtlasTilesTileUuidPut>>,
  TError,
  { tileUuid: string; data: AtlasTileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAtlasTileAtlasTilesTileUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAtlasTileAtlasTilesTileUuidPut>>,
    { tileUuid: string; data: AtlasTileUpdateRequest }
  > = (props) => {
    const { tileUuid, data } = props ?? {}

    return updateAtlasTileAtlasTilesTileUuidPut(tileUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateAtlasTileAtlasTilesTileUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAtlasTileAtlasTilesTileUuidPut>>
>
export type UpdateAtlasTileAtlasTilesTileUuidPutMutationBody = AtlasTileUpdateRequest
export type UpdateAtlasTileAtlasTilesTileUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Atlas Tile
 */
export const useUpdateAtlasTileAtlasTilesTileUuidPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAtlasTileAtlasTilesTileUuidPut>>,
      TError,
      { tileUuid: string; data: AtlasTileUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAtlasTileAtlasTilesTileUuidPut>>,
  TError,
  { tileUuid: string; data: AtlasTileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAtlasTileAtlasTilesTileUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete an atlas tile by publishing to RabbitMQ
 * @summary Delete Atlas Tile
 */
export const deleteAtlasTileAtlasTilesTileUuidDelete = (
  tileUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/atlas-tiles/${tileUuid}`, method: 'DELETE' }, options)
}

export const getDeleteAtlasTileAtlasTilesTileUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAtlasTileAtlasTilesTileUuidDelete>>,
    TError,
    { tileUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAtlasTileAtlasTilesTileUuidDelete>>,
  TError,
  { tileUuid: string },
  TContext
> => {
  const mutationKey = ['deleteAtlasTileAtlasTilesTileUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAtlasTileAtlasTilesTileUuidDelete>>,
    { tileUuid: string }
  > = (props) => {
    const { tileUuid } = props ?? {}

    return deleteAtlasTileAtlasTilesTileUuidDelete(tileUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteAtlasTileAtlasTilesTileUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAtlasTileAtlasTilesTileUuidDelete>>
>

export type DeleteAtlasTileAtlasTilesTileUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Atlas Tile
 */
export const useDeleteAtlasTileAtlasTilesTileUuidDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAtlasTileAtlasTilesTileUuidDelete>>,
      TError,
      { tileUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAtlasTileAtlasTilesTileUuidDelete>>,
  TError,
  { tileUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteAtlasTileAtlasTilesTileUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all tiles for a specific atlas
 * @summary Get Atlas Tiles By Atlas
 */
export const getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet = (
  atlasUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasTileResponse[]>(
    { url: `/atlases/${atlasUuid}/tiles`, method: 'GET', signal },
    options
  )
}

export const getGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGetQueryKey = (atlasUuid?: string) => {
  return [`/atlases/${atlasUuid}/tiles`] as const
}

export const getGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGetQueryKey(atlasUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>
  > = ({ signal }) =>
    getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet(atlasUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!atlasUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAtlasTilesByAtlasAtlasesAtlasUuidTilesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>
>
export type GetAtlasTilesByAtlasAtlasesAtlasUuidTilesGetQueryError = HTTPValidationError

export function useGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
          TError,
          Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Atlas Tiles By Atlas
 */

export function useGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGet<
  TData = Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
  TError = HTTPValidationError,
>(
  atlasUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAtlasTilesByAtlasAtlasesAtlasUuidTilesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAtlasTilesByAtlasAtlasesAtlasUuidTilesGetQueryOptions(
    atlasUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new tile for a specific atlas
 * @summary Create Atlas Tile For Atlas
 */
export const createAtlasTileForAtlasAtlasesAtlasUuidTilesPost = (
  atlasUuid: string,
  atlasTileCreateRequest: AtlasTileCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasTileResponse>(
    {
      url: `/atlases/${atlasUuid}/tiles`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: atlasTileCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateAtlasTileForAtlasAtlasesAtlasUuidTilesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAtlasTileForAtlasAtlasesAtlasUuidTilesPost>>,
    TError,
    { atlasUuid: string; data: AtlasTileCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAtlasTileForAtlasAtlasesAtlasUuidTilesPost>>,
  TError,
  { atlasUuid: string; data: AtlasTileCreateRequest },
  TContext
> => {
  const mutationKey = ['createAtlasTileForAtlasAtlasesAtlasUuidTilesPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAtlasTileForAtlasAtlasesAtlasUuidTilesPost>>,
    { atlasUuid: string; data: AtlasTileCreateRequest }
  > = (props) => {
    const { atlasUuid, data } = props ?? {}

    return createAtlasTileForAtlasAtlasesAtlasUuidTilesPost(atlasUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateAtlasTileForAtlasAtlasesAtlasUuidTilesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAtlasTileForAtlasAtlasesAtlasUuidTilesPost>>
>
export type CreateAtlasTileForAtlasAtlasesAtlasUuidTilesPostMutationBody = AtlasTileCreateRequest
export type CreateAtlasTileForAtlasAtlasesAtlasUuidTilesPostMutationError = HTTPValidationError

/**
 * @summary Create Atlas Tile For Atlas
 */
export const useCreateAtlasTileForAtlasAtlasesAtlasUuidTilesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAtlasTileForAtlasAtlasesAtlasUuidTilesPost>>,
      TError,
      { atlasUuid: string; data: AtlasTileCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createAtlasTileForAtlasAtlasesAtlasUuidTilesPost>>,
  TError,
  { atlasUuid: string; data: AtlasTileCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateAtlasTileForAtlasAtlasesAtlasUuidTilesPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Connect a grid square to a tile with its position information
 * @summary Link Atlas Tile To Gridsquare
 */
export const linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost = (
  tileUuid: string,
  gridsquareUuid: string,
  gridSquarePositionRequest: GridSquarePositionRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasTileGridSquarePositionResponse>(
    {
      url: `/atlas-tiles/${tileUuid}/gridsquares/${gridsquareUuid}`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: gridSquarePositionRequest,
      signal,
    },
    options
  )
}

export const getLinkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost>
      >,
      TError,
      { tileUuid: string; gridsquareUuid: string; data: GridSquarePositionRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost>
    >,
    TError,
    { tileUuid: string; gridsquareUuid: string; data: GridSquarePositionRequest },
    TContext
  > => {
    const mutationKey = ['linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost']
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost>
      >,
      { tileUuid: string; gridsquareUuid: string; data: GridSquarePositionRequest }
    > = (props) => {
      const { tileUuid, gridsquareUuid, data } = props ?? {}

      return linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost(
        tileUuid,
        gridsquareUuid,
        data,
        requestOptions
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type LinkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost>
    >
  >
export type LinkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPostMutationBody =
  GridSquarePositionRequest
export type LinkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPostMutationError =
  HTTPValidationError

/**
 * @summary Link Atlas Tile To Gridsquare
 */
export const useLinkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost>
      >,
      TError,
      { tileUuid: string; gridsquareUuid: string; data: GridSquarePositionRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof linkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPost>
  >,
  TError,
  { tileUuid: string; gridsquareUuid: string; data: GridSquarePositionRequest },
  TContext
> => {
  const mutationOptions =
    getLinkAtlasTileToGridsquareAtlasTilesTileUuidGridsquaresGridsquareUuidPostMutationOptions(
      options
    )

  return useMutation(mutationOptions, queryClient)
}
/**
 * Connect mutliple grid squares to a tile with its position information
 * @summary Link Atlas Tile To Gridsquares
 */
export const linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost = (
  tileUuid: string,
  gridSquarePositionRequest: GridSquarePositionRequest[],
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AtlasTileGridSquarePositionResponse[]>(
    {
      url: `/atlas-tiles/${tileUuid}/gridsquares`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: gridSquarePositionRequest,
      signal,
    },
    options
  )
}

export const getLinkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost>>,
    TError,
    { tileUuid: string; data: GridSquarePositionRequest[] },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost>>,
  TError,
  { tileUuid: string; data: GridSquarePositionRequest[] },
  TContext
> => {
  const mutationKey = ['linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost>>,
    { tileUuid: string; data: GridSquarePositionRequest[] }
  > = (props) => {
    const { tileUuid, data } = props ?? {}

    return linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost(
      tileUuid,
      data,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type LinkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost>>
>
export type LinkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPostMutationBody =
  GridSquarePositionRequest[]
export type LinkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPostMutationError =
  HTTPValidationError

/**
 * @summary Link Atlas Tile To Gridsquares
 */
export const useLinkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost>>,
      TError,
      { tileUuid: string; data: GridSquarePositionRequest[] },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof linkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPost>>,
  TError,
  { tileUuid: string; data: GridSquarePositionRequest[] },
  TContext
> => {
  const mutationOptions =
    getLinkAtlasTileToGridsquaresAtlasTilesTileUuidGridsquaresPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all grid squares
 * @summary Get Gridsquares
 */
export const getGridsquaresGridsquaresGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridSquareResponse[]>(
    { url: `/gridsquares`, method: 'GET', signal },
    options
  )
}

export const getGetGridsquaresGridsquaresGetQueryKey = () => {
  return [`/gridsquares`] as const
}

export const getGetGridsquaresGridsquaresGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGridsquaresGridsquaresGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>> = ({
    signal,
  }) => getGridsquaresGridsquaresGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridsquaresGridsquaresGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>
>
export type GetGridsquaresGridsquaresGetQueryError = unknown

export function useGetGridsquaresGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquaresGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquaresGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Gridsquares
 */

export function useGetGridsquaresGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGridsquaresGridsquaresGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridsquaresGridsquaresGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single grid square by ID
 * @summary Get Gridsquare
 */
export const getGridsquareGridsquaresGridsquareUuidGet = (
  gridsquareUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridSquareResponse>(
    { url: `/gridsquares/${gridsquareUuid}`, method: 'GET', signal },
    options
  )
}

export const getGetGridsquareGridsquaresGridsquareUuidGetQueryKey = (gridsquareUuid?: string) => {
  return [`/gridsquares/${gridsquareUuid}`] as const
}

export const getGetGridsquareGridsquaresGridsquareUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetGridsquareGridsquaresGridsquareUuidGetQueryKey(gridsquareUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>
  > = ({ signal }) =>
    getGridsquareGridsquaresGridsquareUuidGet(gridsquareUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!gridsquareUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridsquareGridsquaresGridsquareUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>
>
export type GetGridsquareGridsquaresGridsquareUuidGetQueryError = HTTPValidationError

export function useGetGridsquareGridsquaresGridsquareUuidGet<
  TData = Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareGridsquaresGridsquareUuidGet<
  TData = Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareGridsquaresGridsquareUuidGet<
  TData = Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Gridsquare
 */

export function useGetGridsquareGridsquaresGridsquareUuidGet<
  TData = Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareGridsquaresGridsquareUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridsquareGridsquaresGridsquareUuidGetQueryOptions(
    gridsquareUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a grid square
 * @summary Update Gridsquare
 */
export const updateGridsquareGridsquaresGridsquareUuidPut = (
  gridsquareUuid: string,
  gridSquareUpdateRequest: GridSquareUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<GridSquareResponse>(
    {
      url: `/gridsquares/${gridsquareUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: gridSquareUpdateRequest,
    },
    options
  )
}

export const getUpdateGridsquareGridsquaresGridsquareUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGridsquareGridsquaresGridsquareUuidPut>>,
    TError,
    { gridsquareUuid: string; data: GridSquareUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGridsquareGridsquaresGridsquareUuidPut>>,
  TError,
  { gridsquareUuid: string; data: GridSquareUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateGridsquareGridsquaresGridsquareUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGridsquareGridsquaresGridsquareUuidPut>>,
    { gridsquareUuid: string; data: GridSquareUpdateRequest }
  > = (props) => {
    const { gridsquareUuid, data } = props ?? {}

    return updateGridsquareGridsquaresGridsquareUuidPut(gridsquareUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateGridsquareGridsquaresGridsquareUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGridsquareGridsquaresGridsquareUuidPut>>
>
export type UpdateGridsquareGridsquaresGridsquareUuidPutMutationBody = GridSquareUpdateRequest
export type UpdateGridsquareGridsquaresGridsquareUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Gridsquare
 */
export const useUpdateGridsquareGridsquaresGridsquareUuidPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateGridsquareGridsquaresGridsquareUuidPut>>,
      TError,
      { gridsquareUuid: string; data: GridSquareUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateGridsquareGridsquaresGridsquareUuidPut>>,
  TError,
  { gridsquareUuid: string; data: GridSquareUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateGridsquareGridsquaresGridsquareUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a grid square by publishing to RabbitMQ
 * @summary Delete Gridsquare
 */
export const deleteGridsquareGridsquaresGridsquareUuidDelete = (
  gridsquareUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/gridsquares/${gridsquareUuid}`, method: 'DELETE' }, options)
}

export const getDeleteGridsquareGridsquaresGridsquareUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGridsquareGridsquaresGridsquareUuidDelete>>,
    TError,
    { gridsquareUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGridsquareGridsquaresGridsquareUuidDelete>>,
  TError,
  { gridsquareUuid: string },
  TContext
> => {
  const mutationKey = ['deleteGridsquareGridsquaresGridsquareUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGridsquareGridsquaresGridsquareUuidDelete>>,
    { gridsquareUuid: string }
  > = (props) => {
    const { gridsquareUuid } = props ?? {}

    return deleteGridsquareGridsquaresGridsquareUuidDelete(gridsquareUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteGridsquareGridsquaresGridsquareUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteGridsquareGridsquaresGridsquareUuidDelete>>
>

export type DeleteGridsquareGridsquaresGridsquareUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Gridsquare
 */
export const useDeleteGridsquareGridsquaresGridsquareUuidDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteGridsquareGridsquaresGridsquareUuidDelete>>,
      TError,
      { gridsquareUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteGridsquareGridsquaresGridsquareUuidDelete>>,
  TError,
  { gridsquareUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteGridsquareGridsquaresGridsquareUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all grid squares for a specific grid
 * @summary Get Grid Gridsquares
 */
export const getGridGridsquaresGridsGridUuidGridsquaresGet = (
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridSquareResponse[]>(
    { url: `/grids/${gridUuid}/gridsquares`, method: 'GET', signal },
    options
  )
}

export const getGetGridGridsquaresGridsGridUuidGridsquaresGetQueryKey = (gridUuid?: string) => {
  return [`/grids/${gridUuid}/gridsquares`] as const
}

export const getGetGridGridsquaresGridsGridUuidGridsquaresGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetGridGridsquaresGridsGridUuidGridsquaresGetQueryKey(gridUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>
  > = ({ signal }) =>
    getGridGridsquaresGridsGridUuidGridsquaresGet(gridUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!gridUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridGridsquaresGridsGridUuidGridsquaresGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>
>
export type GetGridGridsquaresGridsGridUuidGridsquaresGetQueryError = HTTPValidationError

export function useGetGridGridsquaresGridsGridUuidGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
          TError,
          Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridGridsquaresGridsGridUuidGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
          TError,
          Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridGridsquaresGridsGridUuidGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Grid Gridsquares
 */

export function useGetGridGridsquaresGridsGridUuidGridsquaresGet<
  TData = Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridGridsquaresGridsGridUuidGridsquaresGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridGridsquaresGridsGridUuidGridsquaresGetQueryOptions(
    gridUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new grid square for a specific grid
 * @summary Create Grid Gridsquare
 */
export const createGridGridsquareGridsGridUuidGridsquaresPost = (
  gridUuid: string,
  gridSquareCreateRequest: GridSquareCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GridSquareResponse>(
    {
      url: `/grids/${gridUuid}/gridsquares`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: gridSquareCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateGridGridsquareGridsGridUuidGridsquaresPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGridGridsquareGridsGridUuidGridsquaresPost>>,
    TError,
    { gridUuid: string; data: GridSquareCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGridGridsquareGridsGridUuidGridsquaresPost>>,
  TError,
  { gridUuid: string; data: GridSquareCreateRequest },
  TContext
> => {
  const mutationKey = ['createGridGridsquareGridsGridUuidGridsquaresPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGridGridsquareGridsGridUuidGridsquaresPost>>,
    { gridUuid: string; data: GridSquareCreateRequest }
  > = (props) => {
    const { gridUuid, data } = props ?? {}

    return createGridGridsquareGridsGridUuidGridsquaresPost(gridUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateGridGridsquareGridsGridUuidGridsquaresPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGridGridsquareGridsGridUuidGridsquaresPost>>
>
export type CreateGridGridsquareGridsGridUuidGridsquaresPostMutationBody = GridSquareCreateRequest
export type CreateGridGridsquareGridsGridUuidGridsquaresPostMutationError = HTTPValidationError

/**
 * @summary Create Grid Gridsquare
 */
export const useCreateGridGridsquareGridsGridUuidGridsquaresPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGridGridsquareGridsGridUuidGridsquaresPost>>,
      TError,
      { gridUuid: string; data: GridSquareCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createGridGridsquareGridsGridUuidGridsquaresPost>>,
  TError,
  { gridUuid: string; data: GridSquareCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateGridGridsquareGridsGridUuidGridsquaresPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * All holes on a grid square have been registered at square mag
 * @summary Gridsquare Registered
 */
export const gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost = (
  gridsquareUuid: string,
  params?: GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<boolean>(
    { url: `/gridsquares/${gridsquareUuid}/registered`, method: 'POST', params, signal },
    options
  )
}

export const getGridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost>>,
    TError,
    {
      gridsquareUuid: string
      params?: GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost>>,
  TError,
  {
    gridsquareUuid: string
    params?: GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams
  },
  TContext
> => {
  const mutationKey = ['gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost>>,
    {
      gridsquareUuid: string
      params?: GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams
    }
  > = (props) => {
    const { gridsquareUuid, params } = props ?? {}

    return gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost(
      gridsquareUuid,
      params,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost>>
>

export type GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostMutationError =
  HTTPValidationError

/**
 * @summary Gridsquare Registered
 */
export const useGridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost>>,
      TError,
      {
        gridsquareUuid: string
        params?: GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gridsquareRegisteredGridsquaresGridsquareUuidRegisteredPost>>,
  TError,
  {
    gridsquareUuid: string
    params?: GridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostParams
  },
  TContext
> => {
  const mutationOptions =
    getGridsquareRegisteredGridsquaresGridsquareUuidRegisteredPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all foil holes
 * @summary Get Foilholes
 */
export const getFoilholesFoilholesGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<FoilHoleResponse[]>({ url: `/foilholes`, method: 'GET', signal }, options)
}

export const getGetFoilholesFoilholesGetQueryKey = () => {
  return [`/foilholes`] as const
}

export const getGetFoilholesFoilholesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFoilholesFoilholesGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFoilholesFoilholesGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFoilholesFoilholesGet>>> = ({
    signal,
  }) => getFoilholesFoilholesGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoilholesFoilholesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFoilholesFoilholesGet>>
>
export type GetFoilholesFoilholesGetQueryError = unknown

export function useGetFoilholesFoilholesGet<
  TData = Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFoilholesFoilholesGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
          TError,
          Awaited<ReturnType<typeof getFoilholesFoilholesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholesFoilholesGet<
  TData = Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFoilholesFoilholesGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
          TError,
          Awaited<ReturnType<typeof getFoilholesFoilholesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholesFoilholesGet<
  TData = Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFoilholesFoilholesGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Foilholes
 */

export function useGetFoilholesFoilholesGet<
  TData = Awaited<ReturnType<typeof getFoilholesFoilholesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFoilholesFoilholesGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFoilholesFoilholesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single foil hole by ID
 * @summary Get Foilhole
 */
export const getFoilholeFoilholesFoilholeUuidGet = (
  foilholeUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<FoilHoleResponse>(
    { url: `/foilholes/${foilholeUuid}`, method: 'GET', signal },
    options
  )
}

export const getGetFoilholeFoilholesFoilholeUuidGetQueryKey = (foilholeUuid?: string) => {
  return [`/foilholes/${foilholeUuid}`] as const
}

export const getGetFoilholeFoilholesFoilholeUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetFoilholeFoilholesFoilholeUuidGetQueryKey(foilholeUuid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>> = ({
    signal,
  }) => getFoilholeFoilholesFoilholeUuidGet(foilholeUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!foilholeUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoilholeFoilholesFoilholeUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>
>
export type GetFoilholeFoilholesFoilholeUuidGetQueryError = HTTPValidationError

export function useGetFoilholeFoilholesFoilholeUuidGet<
  TData = Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeFoilholesFoilholeUuidGet<
  TData = Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeFoilholesFoilholeUuidGet<
  TData = Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Foilhole
 */

export function useGetFoilholeFoilholesFoilholeUuidGet<
  TData = Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeFoilholesFoilholeUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFoilholeFoilholesFoilholeUuidGetQueryOptions(foilholeUuid, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a foil hole
 * @summary Update Foilhole
 */
export const updateFoilholeFoilholesFoilholeUuidPut = (
  foilholeUuid: string,
  foilHoleUpdateRequest: FoilHoleUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<FoilHoleResponse>(
    {
      url: `/foilholes/${foilholeUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: foilHoleUpdateRequest,
    },
    options
  )
}

export const getUpdateFoilholeFoilholesFoilholeUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFoilholeFoilholesFoilholeUuidPut>>,
    TError,
    { foilholeUuid: string; data: FoilHoleUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFoilholeFoilholesFoilholeUuidPut>>,
  TError,
  { foilholeUuid: string; data: FoilHoleUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateFoilholeFoilholesFoilholeUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFoilholeFoilholesFoilholeUuidPut>>,
    { foilholeUuid: string; data: FoilHoleUpdateRequest }
  > = (props) => {
    const { foilholeUuid, data } = props ?? {}

    return updateFoilholeFoilholesFoilholeUuidPut(foilholeUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateFoilholeFoilholesFoilholeUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFoilholeFoilholesFoilholeUuidPut>>
>
export type UpdateFoilholeFoilholesFoilholeUuidPutMutationBody = FoilHoleUpdateRequest
export type UpdateFoilholeFoilholesFoilholeUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Foilhole
 */
export const useUpdateFoilholeFoilholesFoilholeUuidPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFoilholeFoilholesFoilholeUuidPut>>,
      TError,
      { foilholeUuid: string; data: FoilHoleUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateFoilholeFoilholesFoilholeUuidPut>>,
  TError,
  { foilholeUuid: string; data: FoilHoleUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateFoilholeFoilholesFoilholeUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a foil hole by publishing to RabbitMQ
 * @summary Delete Foilhole
 */
export const deleteFoilholeFoilholesFoilholeUuidDelete = (
  foilholeUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/foilholes/${foilholeUuid}`, method: 'DELETE' }, options)
}

export const getDeleteFoilholeFoilholesFoilholeUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFoilholeFoilholesFoilholeUuidDelete>>,
    TError,
    { foilholeUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFoilholeFoilholesFoilholeUuidDelete>>,
  TError,
  { foilholeUuid: string },
  TContext
> => {
  const mutationKey = ['deleteFoilholeFoilholesFoilholeUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFoilholeFoilholesFoilholeUuidDelete>>,
    { foilholeUuid: string }
  > = (props) => {
    const { foilholeUuid } = props ?? {}

    return deleteFoilholeFoilholesFoilholeUuidDelete(foilholeUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteFoilholeFoilholesFoilholeUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFoilholeFoilholesFoilholeUuidDelete>>
>

export type DeleteFoilholeFoilholesFoilholeUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Foilhole
 */
export const useDeleteFoilholeFoilholesFoilholeUuidDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFoilholeFoilholesFoilholeUuidDelete>>,
      TError,
      { foilholeUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFoilholeFoilholesFoilholeUuidDelete>>,
  TError,
  { foilholeUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteFoilholeFoilholesFoilholeUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all foil holes for a specific grid square
 * @summary Get Gridsquare Foilholes
 */
export const getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet = (
  gridsquareUuid: string,
  params?: GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<FoilHoleResponse[]>(
    { url: `/gridsquares/${gridsquareUuid}/foilholes`, method: 'GET', params, signal },
    options
  )
}

export const getGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetQueryKey = (
  gridsquareUuid?: string,
  params?: GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams
) => {
  return [`/gridsquares/${gridsquareUuid}/foilholes`, ...(params ? [params] : [])] as const
}

export const getGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  params?: GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetQueryKey(gridsquareUuid, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>
  > = ({ signal }) =>
    getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet(
      gridsquareUuid,
      params,
      requestOptions,
      signal
    )

  return {
    queryKey,
    queryFn,
    enabled: !!gridsquareUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>
>
export type GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetQueryError =
  HTTPValidationError

export function useGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet<
  TData = Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  params: undefined | GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet<
  TData = Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  params?: GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet<
  TData = Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  params?: GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Gridsquare Foilholes
 */

export function useGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet<
  TData = Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  params?: GetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridsquareFoilholesGridsquaresGridsquareUuidFoilholesGetQueryOptions(
    gridsquareUuid,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new foil hole for a specific grid square
 * @summary Create Gridsquare Foilhole
 */
export const createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost = (
  gridsquareUuid: string,
  foilHoleCreateRequest: FoilHoleCreateRequest[],
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<FoilHoleResponse[]>(
    {
      url: `/gridsquares/${gridsquareUuid}/foilholes`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: foilHoleCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost>>,
    TError,
    { gridsquareUuid: string; data: FoilHoleCreateRequest[] },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost>>,
  TError,
  { gridsquareUuid: string; data: FoilHoleCreateRequest[] },
  TContext
> => {
  const mutationKey = ['createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost>>,
    { gridsquareUuid: string; data: FoilHoleCreateRequest[] }
  > = (props) => {
    const { gridsquareUuid, data } = props ?? {}

    return createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost(
      gridsquareUuid,
      data,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost>>
  >
export type CreateGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPostMutationBody =
  FoilHoleCreateRequest[]
export type CreateGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPostMutationError =
  HTTPValidationError

/**
 * @summary Create Gridsquare Foilhole
 */
export const useCreateGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost>>,
      TError,
      { gridsquareUuid: string; data: FoilHoleCreateRequest[] },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPost>>,
  TError,
  { gridsquareUuid: string; data: FoilHoleCreateRequest[] },
  TContext
> => {
  const mutationOptions =
    getCreateGridsquareFoilholeGridsquaresGridsquareUuidFoilholesPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all micrographs
 * @summary Get Micrographs
 */
export const getMicrographsMicrographsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MicrographResponse[]>(
    { url: `/micrographs`, method: 'GET', signal },
    options
  )
}

export const getGetMicrographsMicrographsGetQueryKey = () => {
  return [`/micrographs`] as const
}

export const getGetMicrographsMicrographsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMicrographsMicrographsGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetMicrographsMicrographsGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMicrographsMicrographsGet>>> = ({
    signal,
  }) => getMicrographsMicrographsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMicrographsMicrographsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMicrographsMicrographsGet>>
>
export type GetMicrographsMicrographsGetQueryError = unknown

export function useGetMicrographsMicrographsGet<
  TData = Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMicrographsMicrographsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
          TError,
          Awaited<ReturnType<typeof getMicrographsMicrographsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMicrographsMicrographsGet<
  TData = Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMicrographsMicrographsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
          TError,
          Awaited<ReturnType<typeof getMicrographsMicrographsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMicrographsMicrographsGet<
  TData = Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMicrographsMicrographsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Micrographs
 */

export function useGetMicrographsMicrographsGet<
  TData = Awaited<ReturnType<typeof getMicrographsMicrographsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMicrographsMicrographsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMicrographsMicrographsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single micrograph by ID
 * @summary Get Micrograph
 */
export const getMicrographMicrographsMicrographUuidGet = (
  micrographUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MicrographResponse>(
    { url: `/micrographs/${micrographUuid}`, method: 'GET', signal },
    options
  )
}

export const getGetMicrographMicrographsMicrographUuidGetQueryKey = (micrographUuid?: string) => {
  return [`/micrographs/${micrographUuid}`] as const
}

export const getGetMicrographMicrographsMicrographUuidGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
  TError = HTTPValidationError,
>(
  micrographUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetMicrographMicrographsMicrographUuidGetQueryKey(micrographUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>
  > = ({ signal }) =>
    getMicrographMicrographsMicrographUuidGet(micrographUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!micrographUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMicrographMicrographsMicrographUuidGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>
>
export type GetMicrographMicrographsMicrographUuidGetQueryError = HTTPValidationError

export function useGetMicrographMicrographsMicrographUuidGet<
  TData = Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
  TError = HTTPValidationError,
>(
  micrographUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMicrographMicrographsMicrographUuidGet<
  TData = Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
  TError = HTTPValidationError,
>(
  micrographUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
          TError,
          Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMicrographMicrographsMicrographUuidGet<
  TData = Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
  TError = HTTPValidationError,
>(
  micrographUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Micrograph
 */

export function useGetMicrographMicrographsMicrographUuidGet<
  TData = Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
  TError = HTTPValidationError,
>(
  micrographUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMicrographMicrographsMicrographUuidGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMicrographMicrographsMicrographUuidGetQueryOptions(
    micrographUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a micrograph
 * @summary Update Micrograph
 */
export const updateMicrographMicrographsMicrographUuidPut = (
  micrographUuid: string,
  micrographUpdateRequest: MicrographUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<MicrographResponse>(
    {
      url: `/micrographs/${micrographUuid}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: micrographUpdateRequest,
    },
    options
  )
}

export const getUpdateMicrographMicrographsMicrographUuidPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMicrographMicrographsMicrographUuidPut>>,
    TError,
    { micrographUuid: string; data: MicrographUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMicrographMicrographsMicrographUuidPut>>,
  TError,
  { micrographUuid: string; data: MicrographUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMicrographMicrographsMicrographUuidPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMicrographMicrographsMicrographUuidPut>>,
    { micrographUuid: string; data: MicrographUpdateRequest }
  > = (props) => {
    const { micrographUuid, data } = props ?? {}

    return updateMicrographMicrographsMicrographUuidPut(micrographUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateMicrographMicrographsMicrographUuidPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMicrographMicrographsMicrographUuidPut>>
>
export type UpdateMicrographMicrographsMicrographUuidPutMutationBody = MicrographUpdateRequest
export type UpdateMicrographMicrographsMicrographUuidPutMutationError = HTTPValidationError

/**
 * @summary Update Micrograph
 */
export const useUpdateMicrographMicrographsMicrographUuidPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMicrographMicrographsMicrographUuidPut>>,
      TError,
      { micrographUuid: string; data: MicrographUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMicrographMicrographsMicrographUuidPut>>,
  TError,
  { micrographUuid: string; data: MicrographUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMicrographMicrographsMicrographUuidPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a micrograph by publishing to RabbitMQ
 * @summary Delete Micrograph
 */
export const deleteMicrographMicrographsMicrographUuidDelete = (
  micrographUuid: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/micrographs/${micrographUuid}`, method: 'DELETE' }, options)
}

export const getDeleteMicrographMicrographsMicrographUuidDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMicrographMicrographsMicrographUuidDelete>>,
    TError,
    { micrographUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMicrographMicrographsMicrographUuidDelete>>,
  TError,
  { micrographUuid: string },
  TContext
> => {
  const mutationKey = ['deleteMicrographMicrographsMicrographUuidDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMicrographMicrographsMicrographUuidDelete>>,
    { micrographUuid: string }
  > = (props) => {
    const { micrographUuid } = props ?? {}

    return deleteMicrographMicrographsMicrographUuidDelete(micrographUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteMicrographMicrographsMicrographUuidDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMicrographMicrographsMicrographUuidDelete>>
>

export type DeleteMicrographMicrographsMicrographUuidDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Micrograph
 */
export const useDeleteMicrographMicrographsMicrographUuidDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMicrographMicrographsMicrographUuidDelete>>,
      TError,
      { micrographUuid: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMicrographMicrographsMicrographUuidDelete>>,
  TError,
  { micrographUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteMicrographMicrographsMicrographUuidDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get all micrographs for a specific foil hole
 * @summary Get Foilhole Micrographs
 */
export const getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet = (
  foilholeUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MicrographResponse[]>(
    { url: `/foilholes/${foilholeUuid}/micrographs`, method: 'GET', signal },
    options
  )
}

export const getGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGetQueryKey = (
  foilholeUuid?: string
) => {
  return [`/foilholes/${foilholeUuid}/micrographs`] as const
}

export const getGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGetQueryKey(foilholeUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>
  > = ({ signal }) =>
    getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet(foilholeUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!foilholeUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>
>
export type GetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGetQueryError =
  HTTPValidationError

export function useGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet<
  TData = Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
          TError,
          Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet<
  TData = Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
          TError,
          Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet<
  TData = Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Foilhole Micrographs
 */

export function useGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet<
  TData = Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
  TError = HTTPValidationError,
>(
  foilholeUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFoilholeMicrographsFoilholesFoilholeUuidMicrographsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFoilholeMicrographsFoilholesFoilholeUuidMicrographsGetQueryOptions(
    foilholeUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new micrograph for a specific foil hole
 * @summary Create Foilhole Micrograph
 */
export const createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost = (
  foilholeUuid: string,
  micrographCreateRequest: MicrographCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MicrographResponse>(
    {
      url: `/foilholes/${foilholeUuid}/micrographs`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: micrographCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateFoilholeMicrographFoilholesFoilholeUuidMicrographsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost>>,
    TError,
    { foilholeUuid: string; data: MicrographCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost>>,
  TError,
  { foilholeUuid: string; data: MicrographCreateRequest },
  TContext
> => {
  const mutationKey = ['createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost>>,
    { foilholeUuid: string; data: MicrographCreateRequest }
  > = (props) => {
    const { foilholeUuid, data } = props ?? {}

    return createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost(
      foilholeUuid,
      data,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateFoilholeMicrographFoilholesFoilholeUuidMicrographsPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost>>
  >
export type CreateFoilholeMicrographFoilholesFoilholeUuidMicrographsPostMutationBody =
  MicrographCreateRequest
export type CreateFoilholeMicrographFoilholesFoilholeUuidMicrographsPostMutationError =
  HTTPValidationError

/**
 * @summary Create Foilhole Micrograph
 */
export const useCreateFoilholeMicrographFoilholesFoilholeUuidMicrographsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost>>,
      TError,
      { foilholeUuid: string; data: MicrographCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createFoilholeMicrographFoilholesFoilholeUuidMicrographsPost>>,
  TError,
  { foilholeUuid: string; data: MicrographCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateFoilholeMicrographFoilholesFoilholeUuidMicrographsPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get Prediction Models
 */
export const getPredictionModelsPredictionModelsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QualityPredictionModelResponse[]>(
    { url: `/prediction_models`, method: 'GET', signal },
    options
  )
}

export const getGetPredictionModelsPredictionModelsGetQueryKey = () => {
  return [`/prediction_models`] as const
}

export const getGetPredictionModelsPredictionModelsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPredictionModelsPredictionModelsGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>
  > = ({ signal }) => getPredictionModelsPredictionModelsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPredictionModelsPredictionModelsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>
>
export type GetPredictionModelsPredictionModelsGetQueryError = unknown

export function useGetPredictionModelsPredictionModelsGet<
  TData = Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
          TError,
          Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionModelsPredictionModelsGet<
  TData = Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
          TError,
          Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionModelsPredictionModelsGet<
  TData = Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Prediction Models
 */

export function useGetPredictionModelsPredictionModelsGet<
  TData = Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelsPredictionModelsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPredictionModelsPredictionModelsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create Prediction Model
 */
export const createPredictionModelPredictionModelsPost = (
  qualityPredictionModelCreateRequest: QualityPredictionModelCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QualityPredictionModelResponse>(
    {
      url: `/prediction_models`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: qualityPredictionModelCreateRequest,
      signal,
    },
    options
  )
}

export const getCreatePredictionModelPredictionModelsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPredictionModelPredictionModelsPost>>,
    TError,
    { data: QualityPredictionModelCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPredictionModelPredictionModelsPost>>,
  TError,
  { data: QualityPredictionModelCreateRequest },
  TContext
> => {
  const mutationKey = ['createPredictionModelPredictionModelsPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPredictionModelPredictionModelsPost>>,
    { data: QualityPredictionModelCreateRequest }
  > = (props) => {
    const { data } = props ?? {}

    return createPredictionModelPredictionModelsPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreatePredictionModelPredictionModelsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPredictionModelPredictionModelsPost>>
>
export type CreatePredictionModelPredictionModelsPostMutationBody =
  QualityPredictionModelCreateRequest
export type CreatePredictionModelPredictionModelsPostMutationError = HTTPValidationError

/**
 * @summary Create Prediction Model
 */
export const useCreatePredictionModelPredictionModelsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPredictionModelPredictionModelsPost>>,
      TError,
      { data: QualityPredictionModelCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPredictionModelPredictionModelsPost>>,
  TError,
  { data: QualityPredictionModelCreateRequest },
  TContext
> => {
  const mutationOptions = getCreatePredictionModelPredictionModelsPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get Prediction Model
 */
export const getPredictionModelPredictionModelsNameGet = (
  name: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QualityPredictionModelResponse>(
    { url: `/prediction_models/${name}`, method: 'GET', signal },
    options
  )
}

export const getGetPredictionModelPredictionModelsNameGetQueryKey = (name?: string) => {
  return [`/prediction_models/${name}`] as const
}

export const getGetPredictionModelPredictionModelsNameGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
  TError = HTTPValidationError,
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetPredictionModelPredictionModelsNameGetQueryKey(name)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>
  > = ({ signal }) => getPredictionModelPredictionModelsNameGet(name, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPredictionModelPredictionModelsNameGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>
>
export type GetPredictionModelPredictionModelsNameGetQueryError = HTTPValidationError

export function useGetPredictionModelPredictionModelsNameGet<
  TData = Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
  TError = HTTPValidationError,
>(
  name: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
          TError,
          Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionModelPredictionModelsNameGet<
  TData = Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
  TError = HTTPValidationError,
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
          TError,
          Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionModelPredictionModelsNameGet<
  TData = Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
  TError = HTTPValidationError,
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Prediction Model
 */

export function useGetPredictionModelPredictionModelsNameGet<
  TData = Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
  TError = HTTPValidationError,
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPredictionModelPredictionModelsNameGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPredictionModelPredictionModelsNameGetQueryOptions(name, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update Prediction Model
 */
export const updatePredictionModelPredictionModelsNamePut = (
  name: string,
  qualityPredictionModelUpdateRequest: QualityPredictionModelUpdateRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<QualityPredictionModelResponse>(
    {
      url: `/prediction_models/${name}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: qualityPredictionModelUpdateRequest,
    },
    options
  )
}

export const getUpdatePredictionModelPredictionModelsNamePutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePredictionModelPredictionModelsNamePut>>,
    TError,
    { name: string; data: QualityPredictionModelUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePredictionModelPredictionModelsNamePut>>,
  TError,
  { name: string; data: QualityPredictionModelUpdateRequest },
  TContext
> => {
  const mutationKey = ['updatePredictionModelPredictionModelsNamePut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePredictionModelPredictionModelsNamePut>>,
    { name: string; data: QualityPredictionModelUpdateRequest }
  > = (props) => {
    const { name, data } = props ?? {}

    return updatePredictionModelPredictionModelsNamePut(name, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdatePredictionModelPredictionModelsNamePutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePredictionModelPredictionModelsNamePut>>
>
export type UpdatePredictionModelPredictionModelsNamePutMutationBody =
  QualityPredictionModelUpdateRequest
export type UpdatePredictionModelPredictionModelsNamePutMutationError = HTTPValidationError

/**
 * @summary Update Prediction Model
 */
export const useUpdatePredictionModelPredictionModelsNamePut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePredictionModelPredictionModelsNamePut>>,
      TError,
      { name: string; data: QualityPredictionModelUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updatePredictionModelPredictionModelsNamePut>>,
  TError,
  { name: string; data: QualityPredictionModelUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdatePredictionModelPredictionModelsNamePutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Delete Prediction Model
 */
export const deletePredictionModelPredictionModelsNameDelete = (
  name: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>({ url: `/prediction_models/${name}`, method: 'DELETE' }, options)
}

export const getDeletePredictionModelPredictionModelsNameDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePredictionModelPredictionModelsNameDelete>>,
    TError,
    { name: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePredictionModelPredictionModelsNameDelete>>,
  TError,
  { name: string },
  TContext
> => {
  const mutationKey = ['deletePredictionModelPredictionModelsNameDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePredictionModelPredictionModelsNameDelete>>,
    { name: string }
  > = (props) => {
    const { name } = props ?? {}

    return deletePredictionModelPredictionModelsNameDelete(name, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeletePredictionModelPredictionModelsNameDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePredictionModelPredictionModelsNameDelete>>
>

export type DeletePredictionModelPredictionModelsNameDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Prediction Model
 */
export const useDeletePredictionModelPredictionModelsNameDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePredictionModelPredictionModelsNameDelete>>,
      TError,
      { name: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePredictionModelPredictionModelsNameDelete>>,
  TError,
  { name: string },
  TContext
> => {
  const mutationOptions = getDeletePredictionModelPredictionModelsNameDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get time ordered predictions for all models that provide them for this square
 * @summary Get Gridsquare Quality Prediction Time Series
 */
export const getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet =
  (
    gridsquareUuid: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal
  ) => {
    return customInstance<GetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet200>(
      { url: `/gridsquares/${gridsquareUuid}/quality_predictions`, method: 'GET', signal },
      options
    )
  }

export const getGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGetQueryKey =
  (gridsquareUuid?: string) => {
    return [`/gridsquares/${gridsquareUuid}/quality_predictions`] as const
  }

export const getGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    gridsquareUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGetQueryKey(
        gridsquareUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
        >
      >
    > = ({ signal }) =>
      getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet(
        gridsquareUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!gridsquareUuid,
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
      >
    >
  >
export type GetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGetQueryError =
  HTTPValidationError

export function useGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Gridsquare Quality Prediction Time Series
 */

export function useGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetGridsquareQualityPredictionTimeSeriesGridsquaresGridsquareUuidQualityPredictionsGetQueryOptions(
      gridsquareUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get time ordered predictions for all models that provide them for this square
 * @summary Get Foilhole Quality Prediction Time Series For Gridsquare
 */
export const getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet =
  (
    gridsquareUuid: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal
  ) => {
    return customInstance<GetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet200>(
      { url: `/gridsquares/${gridsquareUuid}/foilhole_quality_predictions`, method: 'GET', signal },
      options
    )
  }

export const getGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryKey =
  (gridsquareUuid?: string) => {
    return [`/gridsquares/${gridsquareUuid}/foilhole_quality_predictions`] as const
  }

export const getGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    gridsquareUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryKey(
        gridsquareUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
        >
      >
    > = ({ signal }) =>
      getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet(
        gridsquareUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!gridsquareUuid,
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
      >
    >
  >
export type GetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryError =
  HTTPValidationError

export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Foilhole Quality Prediction Time Series For Gridsquare
 */

export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetFoilholeQualityPredictionTimeSeriesForGridsquareGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryOptions(
      gridsquareUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create Quality Prediction
 */
export const createQualityPredictionQualityPredictionsPost = (
  qualityPredictionCreateRequest: QualityPredictionCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QualityPredictionResponse>(
    {
      url: `/quality_predictions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: qualityPredictionCreateRequest,
      signal,
    },
    options
  )
}

export const getCreateQualityPredictionQualityPredictionsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createQualityPredictionQualityPredictionsPost>>,
    TError,
    { data: QualityPredictionCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createQualityPredictionQualityPredictionsPost>>,
  TError,
  { data: QualityPredictionCreateRequest },
  TContext
> => {
  const mutationKey = ['createQualityPredictionQualityPredictionsPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createQualityPredictionQualityPredictionsPost>>,
    { data: QualityPredictionCreateRequest }
  > = (props) => {
    const { data } = props ?? {}

    return createQualityPredictionQualityPredictionsPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateQualityPredictionQualityPredictionsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createQualityPredictionQualityPredictionsPost>>
>
export type CreateQualityPredictionQualityPredictionsPostMutationBody =
  QualityPredictionCreateRequest
export type CreateQualityPredictionQualityPredictionsPostMutationError = HTTPValidationError

/**
 * @summary Create Quality Prediction
 */
export const useCreateQualityPredictionQualityPredictionsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createQualityPredictionQualityPredictionsPost>>,
      TError,
      { data: QualityPredictionCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createQualityPredictionQualityPredictionsPost>>,
  TError,
  { data: QualityPredictionCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateQualityPredictionQualityPredictionsPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get Quality Metrics
 */
export const getQualityMetricsQualityMetricsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QualityMetricsResponse>(
    { url: `/quality_metrics`, method: 'GET', signal },
    options
  )
}

export const getGetQualityMetricsQualityMetricsGetQueryKey = () => {
  return [`/quality_metrics`] as const
}

export const getGetQualityMetricsQualityMetricsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetQualityMetricsQualityMetricsGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>> = ({
    signal,
  }) => getQualityMetricsQualityMetricsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetQualityMetricsQualityMetricsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>
>
export type GetQualityMetricsQualityMetricsGetQueryError = unknown

export function useGetQualityMetricsQualityMetricsGet<
  TData = Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
          TError,
          Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetQualityMetricsQualityMetricsGet<
  TData = Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
          TError,
          Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetQualityMetricsQualityMetricsGet<
  TData = Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Quality Metrics
 */

export function useGetQualityMetricsQualityMetricsGet<
  TData = Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getQualityMetricsQualityMetricsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetQualityMetricsQualityMetricsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Prediction For Grid
 */
export const getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet = (
  predictionModelName: string,
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QualityPredictionResponse[]>(
    {
      url: `/prediction_model/${predictionModelName}/grid/${gridUuid}/prediction`,
      method: 'GET',
      signal,
    },
    options
  )
}

export const getGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGetQueryKey =
  (predictionModelName?: string, gridUuid?: string) => {
    return [`/prediction_model/${predictionModelName}/grid/${gridUuid}/prediction`] as const
  }

export const getGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
      >
    >,
    TError = HTTPValidationError,
  >(
    predictionModelName: string,
    gridUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGetQueryKey(
        predictionModelName,
        gridUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
        >
      >
    > = ({ signal }) =>
      getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet(
        predictionModelName,
        gridUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!(predictionModelName && gridUuid),
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
      >
    >
  >
export type GetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGetQueryError =
  HTTPValidationError

export function useGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Prediction For Grid
 */

export function useGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetPredictionForGridPredictionModelPredictionModelNameGridGridUuidPredictionGetQueryOptions(
      predictionModelName,
      gridUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Latent Rep
 */
export const getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet = (
  predictionModelName: string,
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LatentRepresentationResponse[]>(
    {
      url: `/prediction_model/${predictionModelName}/grid/${gridUuid}/latent_representation`,
      method: 'GET',
      signal,
    },
    options
  )
}

export const getGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGetQueryKey =
  (predictionModelName?: string, gridUuid?: string) => {
    return [
      `/prediction_model/${predictionModelName}/grid/${gridUuid}/latent_representation`,
    ] as const
  }

export const getGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
      >
    >,
    TError = HTTPValidationError,
  >(
    predictionModelName: string,
    gridUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGetQueryKey(
        predictionModelName,
        gridUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
        >
      >
    > = ({ signal }) =>
      getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet(
        predictionModelName,
        gridUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!(predictionModelName && gridUuid),
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
      >
    >
  >
export type GetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGetQueryError =
  HTTPValidationError

export function useGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Latent Rep
 */

export function useGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetLatentRepPredictionModelPredictionModelNameGridGridUuidLatentRepresentationGetQueryOptions(
      predictionModelName,
      gridUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * SSE endpoint for streaming instructions to agents for a specific session
 * @summary Stream Instructions
 */
export const streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet = (
  agentId: string,
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/agent/${agentId}/session/${sessionId}/instructions/stream`, method: 'GET', signal },
    options
  )
}

export const getStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGetQueryKey = (
  agentId?: string,
  sessionId?: string
) => {
  return [`/agent/${agentId}/session/${sessionId}/instructions/stream`] as const
}

export const getStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
  >,
  TError = HTTPValidationError,
>(
  agentId: string,
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGetQueryKey(
      agentId,
      sessionId
    )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>>
  > = ({ signal }) =>
    streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet(
      agentId,
      sessionId,
      requestOptions,
      signal
    )

  return {
    queryKey,
    queryFn,
    enabled: !!(agentId && sessionId),
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>>
  >
export type StreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGetQueryError =
  HTTPValidationError

export function useStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet<
  TData = Awaited<
    ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
  >,
  TError = HTTPValidationError,
>(
  agentId: string,
  sessionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet<
  TData = Awaited<
    ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
  >,
  TError = HTTPValidationError,
>(
  agentId: string,
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet<
  TData = Awaited<
    ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
  >,
  TError = HTTPValidationError,
>(
  agentId: string,
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Instructions
 */

export function useStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet<
  TData = Awaited<
    ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
  >,
  TError = HTTPValidationError,
>(
  agentId: string,
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof streamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGet>
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getStreamInstructionsAgentAgentIdSessionSessionIdInstructionsStreamGetQueryOptions(
      agentId,
      sessionId,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * HTTP endpoint for instruction acknowledgements with database persistence
 * @summary Acknowledge Instruction
 */
export const acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost = (
  agentId: string,
  sessionId: string,
  instructionId: string,
  agentInstructionAcknowledgement: AgentInstructionAcknowledgement,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AgentInstructionAcknowledgementResponse>(
    {
      url: `/agent/${agentId}/session/${sessionId}/instructions/${instructionId}/ack`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: agentInstructionAcknowledgement,
      signal,
    },
    options
  )
}

export const getAcknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost
        >
      >,
      TError,
      {
        agentId: string
        sessionId: string
        instructionId: string
        data: AgentInstructionAcknowledgement
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost
      >
    >,
    TError,
    {
      agentId: string
      sessionId: string
      instructionId: string
      data: AgentInstructionAcknowledgement
    },
    TContext
  > => {
    const mutationKey = [
      'acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost',
    ]
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost
        >
      >,
      {
        agentId: string
        sessionId: string
        instructionId: string
        data: AgentInstructionAcknowledgement
      }
    > = (props) => {
      const { agentId, sessionId, instructionId, data } = props ?? {}

      return acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost(
        agentId,
        sessionId,
        instructionId,
        data,
        requestOptions
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type AcknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost
      >
    >
  >
export type AcknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPostMutationBody =
  AgentInstructionAcknowledgement
export type AcknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPostMutationError =
  HTTPValidationError

/**
 * @summary Acknowledge Instruction
 */
export const useAcknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost
          >
        >,
        TError,
        {
          agentId: string
          sessionId: string
          instructionId: string
          data: AgentInstructionAcknowledgement
        },
        TContext
      >
      request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof acknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPost
      >
    >,
    TError,
    {
      agentId: string
      sessionId: string
      instructionId: string
      data: AgentInstructionAcknowledgement
    },
    TContext
  > => {
    const mutationOptions =
      getAcknowledgeInstructionAgentAgentIdSessionSessionIdInstructionsInstructionIdAckPostMutationOptions(
        options
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * Agent heartbeat endpoint to update connection health status.

Args:
    agent_id: The agent identifier
    session_id: The session identifier
    db: Database session

Returns:
    Heartbeat response with status and timestamp
 * @summary Agent Heartbeat
 */
export const agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost = (
  agentId: string,
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/agent/${agentId}/session/${sessionId}/heartbeat`, method: 'POST', signal },
    options
  )
}

export const getAgentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost>>,
    TError,
    { agentId: string; sessionId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost>>,
  TError,
  { agentId: string; sessionId: string },
  TContext
> => {
  const mutationKey = ['agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost>>,
    { agentId: string; sessionId: string }
  > = (props) => {
    const { agentId, sessionId } = props ?? {}

    return agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost(
      agentId,
      sessionId,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type AgentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost>>
>

export type AgentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPostMutationError =
  HTTPValidationError

/**
 * @summary Agent Heartbeat
 */
export const useAgentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost>>,
      TError,
      { agentId: string; sessionId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof agentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPost>>,
  TError,
  { agentId: string; sessionId: string },
  TContext
> => {
  const mutationOptions =
    getAgentHeartbeatAgentAgentIdSessionSessionIdHeartbeatPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Debug endpoint to view active agent connections
 * @summary Get Active Connections
 */
export const getActiveConnectionsDebugAgentConnectionsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/debug/agent-connections`, method: 'GET', signal },
    options
  )
}

export const getGetActiveConnectionsDebugAgentConnectionsGetQueryKey = () => {
  return [`/debug/agent-connections`] as const
}

export const getGetActiveConnectionsDebugAgentConnectionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetActiveConnectionsDebugAgentConnectionsGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>
  > = ({ signal }) => getActiveConnectionsDebugAgentConnectionsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveConnectionsDebugAgentConnectionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>
>
export type GetActiveConnectionsDebugAgentConnectionsGetQueryError = unknown

export function useGetActiveConnectionsDebugAgentConnectionsGet<
  TData = Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveConnectionsDebugAgentConnectionsGet<
  TData = Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveConnectionsDebugAgentConnectionsGet<
  TData = Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Active Connections
 */

export function useGetActiveConnectionsDebugAgentConnectionsGet<
  TData = Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveConnectionsDebugAgentConnectionsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetActiveConnectionsDebugAgentConnectionsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Debug endpoint to view instructions for a session
 * @summary Get Session Instructions
 */
export const getSessionInstructionsDebugSessionSessionIdInstructionsGet = (
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/debug/session/${sessionId}/instructions`, method: 'GET', signal },
    options
  )
}

export const getGetSessionInstructionsDebugSessionSessionIdInstructionsGetQueryKey = (
  sessionId?: string
) => {
  return [`/debug/session/${sessionId}/instructions`] as const
}

export const getGetSessionInstructionsDebugSessionSessionIdInstructionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetSessionInstructionsDebugSessionSessionIdInstructionsGetQueryKey(sessionId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>
  > = ({ signal }) =>
    getSessionInstructionsDebugSessionSessionIdInstructionsGet(sessionId, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!sessionId,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionInstructionsDebugSessionSessionIdInstructionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>
>
export type GetSessionInstructionsDebugSessionSessionIdInstructionsGetQueryError =
  HTTPValidationError

export function useGetSessionInstructionsDebugSessionSessionIdInstructionsGet<
  TData = Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionInstructionsDebugSessionSessionIdInstructionsGet<
  TData = Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionInstructionsDebugSessionSessionIdInstructionsGet<
  TData = Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Session Instructions
 */

export function useGetSessionInstructionsDebugSessionSessionIdInstructionsGet<
  TData = Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionInstructionsDebugSessionSessionIdInstructionsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSessionInstructionsDebugSessionSessionIdInstructionsGetQueryOptions(
    sessionId,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Debug endpoint to view all active sessions
 * @summary Get Active Sessions
 */
export const getActiveSessionsDebugSessionsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/debug/sessions`, method: 'GET', signal }, options)
}

export const getGetActiveSessionsDebugSessionsGetQueryKey = () => {
  return [`/debug/sessions`] as const
}

export const getGetActiveSessionsDebugSessionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetActiveSessionsDebugSessionsGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>> = ({
    signal,
  }) => getActiveSessionsDebugSessionsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveSessionsDebugSessionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>
>
export type GetActiveSessionsDebugSessionsGetQueryError = unknown

export function useGetActiveSessionsDebugSessionsGet<
  TData = Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveSessionsDebugSessionsGet<
  TData = Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveSessionsDebugSessionsGet<
  TData = Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Active Sessions
 */

export function useGetActiveSessionsDebugSessionsGet<
  TData = Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionsDebugSessionsGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetActiveSessionsDebugSessionsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get real-time connection and session statistics
 * @summary Get Connection Stats
 */
export const getConnectionStatsDebugConnectionStatsGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/debug/connection-stats`, method: 'GET', signal }, options)
}

export const getGetConnectionStatsDebugConnectionStatsGetQueryKey = () => {
  return [`/debug/connection-stats`] as const
}

export const getGetConnectionStatsDebugConnectionStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetConnectionStatsDebugConnectionStatsGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>
  > = ({ signal }) => getConnectionStatsDebugConnectionStatsGet(requestOptions, signal)

  return { queryKey, queryFn, staleTime: 300000, retry: 1, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConnectionStatsDebugConnectionStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>
>
export type GetConnectionStatsDebugConnectionStatsGetQueryError = unknown

export function useGetConnectionStatsDebugConnectionStatsGet<
  TData = Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConnectionStatsDebugConnectionStatsGet<
  TData = Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConnectionStatsDebugConnectionStatsGet<
  TData = Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Connection Stats
 */

export function useGetConnectionStatsDebugConnectionStatsGet<
  TData = Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionStatsDebugConnectionStatsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConnectionStatsDebugConnectionStatsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a session using the connection manager
 * @summary Create Managed Session
 */
export const createManagedSessionDebugSessionsCreateManagedPost = (
  createManagedSessionDebugSessionsCreateManagedPostBody: CreateManagedSessionDebugSessionsCreateManagedPostBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/debug/sessions/create-managed`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createManagedSessionDebugSessionsCreateManagedPostBody,
      signal,
    },
    options
  )
}

export const getCreateManagedSessionDebugSessionsCreateManagedPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createManagedSessionDebugSessionsCreateManagedPost>>,
    TError,
    { data: CreateManagedSessionDebugSessionsCreateManagedPostBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createManagedSessionDebugSessionsCreateManagedPost>>,
  TError,
  { data: CreateManagedSessionDebugSessionsCreateManagedPostBody },
  TContext
> => {
  const mutationKey = ['createManagedSessionDebugSessionsCreateManagedPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createManagedSessionDebugSessionsCreateManagedPost>>,
    { data: CreateManagedSessionDebugSessionsCreateManagedPostBody }
  > = (props) => {
    const { data } = props ?? {}

    return createManagedSessionDebugSessionsCreateManagedPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateManagedSessionDebugSessionsCreateManagedPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createManagedSessionDebugSessionsCreateManagedPost>>
>
export type CreateManagedSessionDebugSessionsCreateManagedPostMutationBody =
  CreateManagedSessionDebugSessionsCreateManagedPostBody
export type CreateManagedSessionDebugSessionsCreateManagedPostMutationError = HTTPValidationError

/**
 * @summary Create Managed Session
 */
export const useCreateManagedSessionDebugSessionsCreateManagedPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createManagedSessionDebugSessionsCreateManagedPost>>,
      TError,
      { data: CreateManagedSessionDebugSessionsCreateManagedPostBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createManagedSessionDebugSessionsCreateManagedPost>>,
  TError,
  { data: CreateManagedSessionDebugSessionsCreateManagedPostBody },
  TContext
> => {
  const mutationOptions =
    getCreateManagedSessionDebugSessionsCreateManagedPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Close a session using the connection manager
 * @summary Close Managed Session
 */
export const closeManagedSessionDebugSessionsSessionIdCloseDelete = (
  sessionId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<unknown>(
    { url: `/debug/sessions/${sessionId}/close`, method: 'DELETE' },
    options
  )
}

export const getCloseManagedSessionDebugSessionsSessionIdCloseDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof closeManagedSessionDebugSessionsSessionIdCloseDelete>>,
    TError,
    { sessionId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof closeManagedSessionDebugSessionsSessionIdCloseDelete>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationKey = ['closeManagedSessionDebugSessionsSessionIdCloseDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof closeManagedSessionDebugSessionsSessionIdCloseDelete>>,
    { sessionId: string }
  > = (props) => {
    const { sessionId } = props ?? {}

    return closeManagedSessionDebugSessionsSessionIdCloseDelete(sessionId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CloseManagedSessionDebugSessionsSessionIdCloseDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof closeManagedSessionDebugSessionsSessionIdCloseDelete>>
>

export type CloseManagedSessionDebugSessionsSessionIdCloseDeleteMutationError = HTTPValidationError

/**
 * @summary Close Managed Session
 */
export const useCloseManagedSessionDebugSessionsSessionIdCloseDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof closeManagedSessionDebugSessionsSessionIdCloseDelete>>,
      TError,
      { sessionId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof closeManagedSessionDebugSessionsSessionIdCloseDelete>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationOptions =
    getCloseManagedSessionDebugSessionsSessionIdCloseDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Debug endpoint to create test instructions
 * @summary Create Test Instruction
 */
export const createTestInstructionDebugSessionSessionIdCreateInstructionPost = (
  sessionId: string,
  createTestInstructionDebugSessionSessionIdCreateInstructionPostBody: CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/debug/session/${sessionId}/create-instruction`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createTestInstructionDebugSessionSessionIdCreateInstructionPostBody,
      signal,
    },
    options
  )
}

export const getCreateTestInstructionDebugSessionSessionIdCreateInstructionPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTestInstructionDebugSessionSessionIdCreateInstructionPost>>,
    TError,
    {
      sessionId: string
      data: CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTestInstructionDebugSessionSessionIdCreateInstructionPost>>,
  TError,
  { sessionId: string; data: CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody },
  TContext
> => {
  const mutationKey = ['createTestInstructionDebugSessionSessionIdCreateInstructionPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTestInstructionDebugSessionSessionIdCreateInstructionPost>>,
    { sessionId: string; data: CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody }
  > = (props) => {
    const { sessionId, data } = props ?? {}

    return createTestInstructionDebugSessionSessionIdCreateInstructionPost(
      sessionId,
      data,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateTestInstructionDebugSessionSessionIdCreateInstructionPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createTestInstructionDebugSessionSessionIdCreateInstructionPost>>
  >
export type CreateTestInstructionDebugSessionSessionIdCreateInstructionPostMutationBody =
  CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody
export type CreateTestInstructionDebugSessionSessionIdCreateInstructionPostMutationError =
  HTTPValidationError

/**
 * @summary Create Test Instruction
 */
export const useCreateTestInstructionDebugSessionSessionIdCreateInstructionPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTestInstructionDebugSessionSessionIdCreateInstructionPost>>,
      TError,
      {
        sessionId: string
        data: CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createTestInstructionDebugSessionSessionIdCreateInstructionPost>>,
  TError,
  { sessionId: string; data: CreateTestInstructionDebugSessionSessionIdCreateInstructionPostBody },
  TContext
> => {
  const mutationOptions =
    getCreateTestInstructionDebugSessionSessionIdCreateInstructionPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Debug endpoint to create test sessions
 * @summary Create Test Session
 */
export const createTestSessionDebugSessionsCreatePost = (
  createTestSessionDebugSessionsCreatePostBody: CreateTestSessionDebugSessionsCreatePostBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/debug/sessions/create`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createTestSessionDebugSessionsCreatePostBody,
      signal,
    },
    options
  )
}

export const getCreateTestSessionDebugSessionsCreatePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTestSessionDebugSessionsCreatePost>>,
    TError,
    { data: CreateTestSessionDebugSessionsCreatePostBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTestSessionDebugSessionsCreatePost>>,
  TError,
  { data: CreateTestSessionDebugSessionsCreatePostBody },
  TContext
> => {
  const mutationKey = ['createTestSessionDebugSessionsCreatePost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTestSessionDebugSessionsCreatePost>>,
    { data: CreateTestSessionDebugSessionsCreatePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return createTestSessionDebugSessionsCreatePost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateTestSessionDebugSessionsCreatePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTestSessionDebugSessionsCreatePost>>
>
export type CreateTestSessionDebugSessionsCreatePostMutationBody =
  CreateTestSessionDebugSessionsCreatePostBody
export type CreateTestSessionDebugSessionsCreatePostMutationError = HTTPValidationError

/**
 * @summary Create Test Session
 */
export const useCreateTestSessionDebugSessionsCreatePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTestSessionDebugSessionsCreatePost>>,
      TError,
      { data: CreateTestSessionDebugSessionsCreatePostBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createTestSessionDebugSessionsCreatePost>>,
  TError,
  { data: CreateTestSessionDebugSessionsCreatePostBody },
  TContext
> => {
  const mutationOptions = getCreateTestSessionDebugSessionsCreatePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get time series of model weights for grid
 * @summary Get Model Weights For Grid
 */
export const getModelWeightsForGridGridGridUuidModelWeightsGet = (
  gridUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GetModelWeightsForGridGridGridUuidModelWeightsGet200>(
    { url: `/grid/${gridUuid}/model_weights`, method: 'GET', signal },
    options
  )
}

export const getGetModelWeightsForGridGridGridUuidModelWeightsGetQueryKey = (gridUuid?: string) => {
  return [`/grid/${gridUuid}/model_weights`] as const
}

export const getGetModelWeightsForGridGridGridUuidModelWeightsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetModelWeightsForGridGridGridUuidModelWeightsGetQueryKey(gridUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>
  > = ({ signal }) =>
    getModelWeightsForGridGridGridUuidModelWeightsGet(gridUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!gridUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelWeightsForGridGridGridUuidModelWeightsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>
>
export type GetModelWeightsForGridGridGridUuidModelWeightsGetQueryError = HTTPValidationError

export function useGetModelWeightsForGridGridGridUuidModelWeightsGet<
  TData = Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
          TError,
          Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelWeightsForGridGridGridUuidModelWeightsGet<
  TData = Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
          TError,
          Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelWeightsForGridGridGridUuidModelWeightsGet<
  TData = Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model Weights For Grid
 */

export function useGetModelWeightsForGridGridGridUuidModelWeightsGet<
  TData = Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModelWeightsForGridGridGridUuidModelWeightsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetModelWeightsForGridGridGridUuidModelWeightsGetQueryOptions(
    gridUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get time ordered predictions for all models that provide them for this square
 * @summary Get Foilhole Quality Prediction Time Series For Gridsquare For Metric
 */
export const getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet =
  (
    metricName: string,
    gridsquareUuid: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal
  ) => {
    return customInstance<GetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet200>(
      {
        url: `/quality_metric/${metricName}/gridsquares/${gridsquareUuid}/foilhole_quality_predictions`,
        method: 'GET',
        signal,
      },
      options
    )
  }

export const getGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryKey =
  (metricName?: string, gridsquareUuid?: string) => {
    return [
      `/quality_metric/${metricName}/gridsquares/${gridsquareUuid}/foilhole_quality_predictions`,
    ] as const
  }

export const getGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    metricName: string,
    gridsquareUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryKey(
        metricName,
        gridsquareUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
        >
      >
    > = ({ signal }) =>
      getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet(
        metricName,
        gridsquareUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!(metricName && gridsquareUuid),
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
      >
    >
  >
export type GetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryError =
  HTTPValidationError

export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  metricName: string,
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  metricName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  metricName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Foilhole Quality Prediction Time Series For Gridsquare For Metric
 */

export function useGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet<
  TData = Awaited<
    ReturnType<
      typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  metricName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetFoilholeQualityPredictionTimeSeriesForGridsquareForMetricQualityMetricMetricNameGridsquaresGridsquareUuidFoilholeQualityPredictionsGetQueryOptions(
      metricName,
      gridsquareUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Prediction For Gridsquare
 */
export const getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet =
  (
    predictionModelName: string,
    gridsquareUuid: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal
  ) => {
    return customInstance<QualityPredictionResponse[]>(
      {
        url: `/prediction_model/${predictionModelName}/gridsquare/${gridsquareUuid}/prediction`,
        method: 'GET',
        signal,
      },
      options
    )
  }

export const getGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGetQueryKey =
  (predictionModelName?: string, gridsquareUuid?: string) => {
    return [
      `/prediction_model/${predictionModelName}/gridsquare/${gridsquareUuid}/prediction`,
    ] as const
  }

export const getGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
      >
    >,
    TError = HTTPValidationError,
  >(
    predictionModelName: string,
    gridsquareUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGetQueryKey(
        predictionModelName,
        gridsquareUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
        >
      >
    > = ({ signal }) =>
      getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet(
        predictionModelName,
        gridsquareUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!(predictionModelName && gridsquareUuid),
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
      >
    >
  >
export type GetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGetQueryError =
  HTTPValidationError

export function useGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Prediction For Gridsquare
 */

export function useGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet<
  TData = Awaited<
    ReturnType<
      typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetPredictionForGridsquarePredictionModelPredictionModelNameGridsquareGridsquareUuidPredictionGetQueryOptions(
      predictionModelName,
      gridsquareUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Overall Prediction For Gridsquare
 */
export const getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet = (
  gridsquareUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OverallQualityPrediction[]>(
    { url: `/gridsquare/${gridsquareUuid}/overall_prediction`, method: 'GET', signal },
    options
  )
}

export const getGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGetQueryKey =
  (gridsquareUuid?: string) => {
    return [`/gridsquare/${gridsquareUuid}/overall_prediction`] as const
  }

export const getGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
      >
    >,
    TError = HTTPValidationError,
  >(
    gridsquareUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGetQueryKey(
        gridsquareUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
        >
      >
    > = ({ signal }) =>
      getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet(
        gridsquareUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!gridsquareUuid,
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
      >
    >
  >
export type GetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGetQueryError =
  HTTPValidationError

export function useGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet<
  TData = Awaited<
    ReturnType<typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet>
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet<
  TData = Awaited<
    ReturnType<typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet>
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet<
  TData = Awaited<
    ReturnType<typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet>
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Overall Prediction For Gridsquare
 */

export function useGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet<
  TData = Awaited<
    ReturnType<typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet>
  >,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetOverallPredictionForGridsquareGridsquareGridsquareUuidOverallPredictionGetQueryOptions(
      gridsquareUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Suggested Square Collections
 */
export const getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet =
  (
    gridUuid: string,
    predictionModelName: string,
    latentRepModelName: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal
  ) => {
    return customInstance<GridSquare[]>(
      {
        url: `/grid/${gridUuid}/prediction_model/${predictionModelName}/latent_rep/${latentRepModelName}/suggested_squares`,
        method: 'GET',
        signal,
      },
      options
    )
  }

export const getGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGetQueryKey =
  (gridUuid?: string, predictionModelName?: string, latentRepModelName?: string) => {
    return [
      `/grid/${gridUuid}/prediction_model/${predictionModelName}/latent_rep/${latentRepModelName}/suggested_squares`,
    ] as const
  }

export const getGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
      >
    >,
    TError = HTTPValidationError,
  >(
    gridUuid: string,
    predictionModelName: string,
    latentRepModelName: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGetQueryKey(
        gridUuid,
        predictionModelName,
        latentRepModelName
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
        >
      >
    > = ({ signal }) =>
      getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet(
        gridUuid,
        predictionModelName,
        latentRepModelName,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!(gridUuid && predictionModelName && latentRepModelName),
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
      >
    >
  >
export type GetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGetQueryError =
  HTTPValidationError

export function useGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet<
  TData = Awaited<
    ReturnType<
      typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  predictionModelName: string,
  latentRepModelName: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet<
  TData = Awaited<
    ReturnType<
      typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  predictionModelName: string,
  latentRepModelName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet<
  TData = Awaited<
    ReturnType<
      typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  predictionModelName: string,
  latentRepModelName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Suggested Square Collections
 */

export function useGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet<
  TData = Awaited<
    ReturnType<
      typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
    >
  >,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  predictionModelName: string,
  latentRepModelName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetSuggestedSquareCollectionsGridGridUuidPredictionModelPredictionModelNameLatentRepLatentRepModelNameSuggestedSquaresGetQueryOptions(
      gridUuid,
      predictionModelName,
      latentRepModelName,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Square Latent Rep
 */
export const getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet =
  (
    predictionModelName: string,
    gridsquareUuid: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal
  ) => {
    return customInstance<LatentRepresentationResponse[]>(
      {
        url: `/prediction_model/${predictionModelName}/gridsquare/${gridsquareUuid}/latent_representation`,
        method: 'GET',
        signal,
      },
      options
    )
  }

export const getGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGetQueryKey =
  (predictionModelName?: string, gridsquareUuid?: string) => {
    return [
      `/prediction_model/${predictionModelName}/gridsquare/${gridsquareUuid}/latent_representation`,
    ] as const
  }

export const getGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
      >
    >,
    TError = HTTPValidationError,
  >(
    predictionModelName: string,
    gridsquareUuid: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
            >
          >,
          TError,
          TData
        >
      >
      request?: SecondParameter<typeof customInstance>
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGetQueryKey(
        predictionModelName,
        gridsquareUuid
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
        >
      >
    > = ({ signal }) =>
      getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet(
        predictionModelName,
        gridsquareUuid,
        requestOptions,
        signal
      )

    return {
      queryKey,
      queryFn,
      enabled: !!(predictionModelName && gridsquareUuid),
      staleTime: 300000,
      retry: 1,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
      >
    >
  >
export type GetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGetQueryError =
  HTTPValidationError

export function useGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
            >
          >
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Square Latent Rep
 */

export function useGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet<
  TData = Awaited<
    ReturnType<
      typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
    >
  >,
  TError = HTTPValidationError,
>(
  predictionModelName: string,
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGet
          >
        >,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetSquareLatentRepPredictionModelPredictionModelNameGridsquareGridsquareUuidLatentRepresentationGetQueryOptions(
      predictionModelName,
      gridsquareUuid,
      options
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single grid by ID
 * @summary Get Grid Atlas Image
 */
export const getGridAtlasImageGridsGridUuidAtlasImageGet = (
  gridUuid: string,
  params?: GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/grids/${gridUuid}/atlas_image`, method: 'GET', params, signal },
    options
  )
}

export const getGetGridAtlasImageGridsGridUuidAtlasImageGetQueryKey = (
  gridUuid?: string,
  params?: GetGridAtlasImageGridsGridUuidAtlasImageGetParams
) => {
  return [`/grids/${gridUuid}/atlas_image`, ...(params ? [params] : [])] as const
}

export const getGetGridAtlasImageGridsGridUuidAtlasImageGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  params?: GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetGridAtlasImageGridsGridUuidAtlasImageGetQueryKey(gridUuid, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>
  > = ({ signal }) =>
    getGridAtlasImageGridsGridUuidAtlasImageGet(gridUuid, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!gridUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridAtlasImageGridsGridUuidAtlasImageGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>
>
export type GetGridAtlasImageGridsGridUuidAtlasImageGetQueryError = HTTPValidationError

export function useGetGridAtlasImageGridsGridUuidAtlasImageGet<
  TData = Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  params: undefined | GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
          TError,
          Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridAtlasImageGridsGridUuidAtlasImageGet<
  TData = Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  params?: GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
          TError,
          Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridAtlasImageGridsGridUuidAtlasImageGet<
  TData = Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  params?: GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Grid Atlas Image
 */

export function useGetGridAtlasImageGridsGridUuidAtlasImageGet<
  TData = Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
  TError = HTTPValidationError,
>(
  gridUuid: string,
  params?: GetGridAtlasImageGridsGridUuidAtlasImageGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridAtlasImageGridsGridUuidAtlasImageGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridAtlasImageGridsGridUuidAtlasImageGetQueryOptions(
    gridUuid,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a single grid square by ID
 * @summary Get Gridsquare Image
 */
export const getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet = (
  gridsquareUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/gridsquares/${gridsquareUuid}/gridsquare_image`, method: 'GET', signal },
    options
  )
}

export const getGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGetQueryKey = (
  gridsquareUuid?: string
) => {
  return [`/gridsquares/${gridsquareUuid}/gridsquare_image`] as const
}

export const getGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGetQueryKey(gridsquareUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>
  > = ({ signal }) =>
    getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet(
      gridsquareUuid,
      requestOptions,
      signal
    )

  return {
    queryKey,
    queryFn,
    enabled: !!gridsquareUuid,
    staleTime: 300000,
    retry: 1,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>
>
export type GetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGetQueryError =
  HTTPValidationError

export function useGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet<
  TData = Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet<
  TData = Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
          TError,
          Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet<
  TData = Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Gridsquare Image
 */

export function useGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet<
  TData = Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
  TError = HTTPValidationError,
>(
  gridsquareUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGridsquareImageGridsquaresGridsquareUuidGridsquareImageGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGridsquareImageGridsquaresGridsquareUuidGridsquareImageGetQueryOptions(
    gridsquareUuid,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}
